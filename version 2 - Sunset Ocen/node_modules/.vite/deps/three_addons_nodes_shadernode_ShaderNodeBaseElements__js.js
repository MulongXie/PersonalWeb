import {
  Color,
  MathUtils,
  Matrix3,
  Matrix4,
  Vector2,
  Vector3,
  Vector4
} from "./chunk-2KJRVID4.js";
import {
  __publicField
} from "./chunk-T2T6Q22Z.js";

// node_modules/three/examples/jsm/nodes/core/constants.js
var NodeShaderStage = {
  Vertex: "vertex",
  Fragment: "fragment"
};
var NodeUpdateType = {
  None: "none",
  Frame: "frame",
  Object: "object"
};

// node_modules/three/examples/jsm/nodes/core/NodeUtils.js
var getCacheKey = (object) => {
  let cacheKey = "{";
  if (object.isNode === true) {
    cacheKey += `uuid:"${object.uuid}",`;
  }
  for (const property2 of getNodesKeys(object)) {
    cacheKey += `${property2}:${object[property2].getCacheKey()},`;
  }
  cacheKey += "}";
  return cacheKey;
};
var getNodesKeys = (object) => {
  const props = [];
  for (const name in object) {
    const value = object[name];
    if (value && value.isNode === true) {
      props.push(name);
    }
  }
  return props;
};
var getValueType = (value) => {
  if (typeof value === "number") {
    return "float";
  } else if (typeof value === "boolean") {
    return "bool";
  } else if ((value == null ? void 0 : value.isVector2) === true) {
    return "vec2";
  } else if ((value == null ? void 0 : value.isVector3) === true) {
    return "vec3";
  } else if ((value == null ? void 0 : value.isVector4) === true) {
    return "vec4";
  } else if ((value == null ? void 0 : value.isMatrix3) === true) {
    return "mat3";
  } else if ((value == null ? void 0 : value.isMatrix4) === true) {
    return "mat4";
  } else if ((value == null ? void 0 : value.isColor) === true) {
    return "color";
  }
  return null;
};
var getValueFromType = (type, ...params) => {
  const last4 = type == null ? void 0 : type.slice(-4);
  if (type === "color") {
    return new Color(...params);
  } else if (last4 === "vec2") {
    return new Vector2(...params);
  } else if (last4 === "vec3") {
    return new Vector3(...params);
  } else if (last4 === "vec4") {
    return new Vector4(...params);
  } else if (last4 === "mat3") {
    return new Matrix3(...params);
  } else if (last4 === "mat4") {
    return new Matrix4(...params);
  } else if (type === "bool") {
    return false;
  } else if (type === "float" || type === "int" || type === "uint") {
    return 0;
  }
  return null;
};

// node_modules/three/examples/jsm/nodes/core/Node.js
var _nodeId = 0;
var Node = class {
  constructor(nodeType = null) {
    this.isNode = true;
    this.nodeType = nodeType;
    this.updateType = NodeUpdateType.None;
    this.uuid = MathUtils.generateUUID();
    Object.defineProperty(this, "id", { value: _nodeId++ });
  }
  get type() {
    return this.constructor.name;
  }
  getChildren() {
    const children = [];
    for (const property2 in this) {
      const object = this[property2];
      if (Array.isArray(object) === true) {
        for (const child of object) {
          if ((child == null ? void 0 : child.isNode) === true) {
            children.push(child);
          }
        }
      } else if ((object == null ? void 0 : object.isNode) === true) {
        children.push(object);
      }
    }
    return children;
  }
  getCacheKey() {
    return getCacheKey(this);
  }
  getHash() {
    return this.uuid;
  }
  getUpdateType() {
    return this.updateType;
  }
  getNodeType() {
    return this.nodeType;
  }
  getConstructHash() {
    return this.uuid;
  }
  getReference(builder) {
    const hash = this.getHash(builder);
    const nodeFromHash = builder.getNodeFromHash(hash);
    return nodeFromHash || this;
  }
  construct(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    for (const childNode of this.getChildren()) {
      nodeProperties["_node" + childNode.id] = childNode;
    }
    return null;
  }
  analyze(builder) {
    const nodeData = builder.getDataFromNode(this);
    nodeData.dependenciesCount = nodeData.dependenciesCount === void 0 ? 1 : nodeData.dependenciesCount + 1;
    if (nodeData.dependenciesCount === 1) {
      const nodeProperties = builder.getNodeProperties(this);
      for (const childNode of Object.values(nodeProperties)) {
        if ((childNode == null ? void 0 : childNode.isNode) === true) {
          childNode.build(builder);
        }
      }
    }
  }
  generate(builder, output) {
    const { outputNode } = builder.getNodeProperties(this);
    if ((outputNode == null ? void 0 : outputNode.isNode) === true) {
      return outputNode.build(builder, output);
    }
  }
  update() {
    console.warn("Abstract function.");
  }
  build(builder, output = null) {
    const refNode = this.getReference(builder);
    if (this !== refNode) {
      return refNode.build(builder, output);
    }
    builder.addNode(this);
    builder.addStack(this);
    let result = null;
    const buildStage = builder.getBuildStage();
    if (buildStage === "construct") {
      const properties = builder.getNodeProperties(this);
      if (properties.initialized !== true || builder.context.tempRead === false) {
        properties.initialized = true;
        properties.outputNode = this.construct(builder);
        for (const childNode of Object.values(properties)) {
          if ((childNode == null ? void 0 : childNode.isNode) === true) {
            childNode.build(builder);
          }
        }
      }
    } else if (buildStage === "analyze") {
      this.analyze(builder);
    } else if (buildStage === "generate") {
      const isGenerateOnce = this.generate.length === 1;
      if (isGenerateOnce) {
        const type = this.getNodeType(builder);
        const nodeData = builder.getDataFromNode(this);
        result = nodeData.snippet;
        if (result === void 0) {
          result = this.generate(builder) || "";
          nodeData.snippet = result;
        }
        result = builder.format(result, type, output);
      } else {
        result = this.generate(builder, output) || "";
      }
    }
    builder.removeStack(this);
    return result;
  }
  serialize(json) {
    const nodeKeys = getNodesKeys(this);
    if (nodeKeys.length > 0) {
      const inputNodes = {};
      for (const property2 of nodeKeys) {
        inputNodes[property2] = this[property2].toJSON(json.meta).uuid;
      }
      json.inputNodes = inputNodes;
    }
  }
  deserialize(json) {
    if (json.inputNodes !== void 0) {
      const nodes = json.meta.nodes;
      for (const property2 in json.inputNodes) {
        const uuid = json.inputNodes[property2];
        this[property2] = nodes[uuid];
      }
    }
  }
  toJSON(meta) {
    const { uuid, type } = this;
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    let data = meta.nodes[uuid];
    if (data === void 0) {
      data = {
        uuid,
        type,
        meta,
        metadata: {
          version: 4.5,
          type: "Node",
          generator: "Node.toJSON"
        }
      };
      meta.nodes[data.uuid] = data;
      this.serialize(data);
      delete data.meta;
    }
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
      if (nodes.length > 0)
        data.nodes = nodes;
    }
    return data;
  }
};
var Node_default = Node;

// node_modules/three/examples/jsm/nodes/core/VaryingNode.js
var VaryingNode = class extends Node_default {
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    const node = this.node;
    const name = this.name;
    const nodeVarying = builder.getVaryingFromNode(this, type);
    if (name !== null) {
      nodeVarying.name = name;
    }
    const propertyName = builder.getPropertyName(nodeVarying, NodeShaderStage.Vertex);
    builder.flowNodeFromShaderStage(NodeShaderStage.Vertex, node, type, propertyName);
    return builder.getPropertyName(nodeVarying);
  }
};
var VaryingNode_default = VaryingNode;

// node_modules/three/examples/jsm/nodes/core/AttributeNode.js
var AttributeNode = class extends Node_default {
  constructor(attributeName, nodeType = null) {
    super(nodeType);
    this._attributeName = attributeName;
  }
  getHash(builder) {
    return this.getAttributeName(builder);
  }
  getNodeType(builder) {
    let nodeType = super.getNodeType(builder);
    if (nodeType === null) {
      const attributeName = this.getAttributeName(builder);
      const attribute2 = builder.geometry.getAttribute(attributeName);
      nodeType = builder.getTypeFromLength(attribute2.itemSize);
    }
    return nodeType;
  }
  setAttributeName(attributeName) {
    this._attributeName = attributeName;
    return this;
  }
  getAttributeName() {
    return this._attributeName;
  }
  generate(builder) {
    const attribute2 = builder.getAttribute(this.getAttributeName(builder), this.getNodeType(builder));
    if (builder.isShaderStage("vertex")) {
      return attribute2.name;
    } else {
      const nodeVarying = new VaryingNode_default(this);
      return nodeVarying.build(builder, attribute2.type);
    }
  }
};
var AttributeNode_default = AttributeNode;

// node_modules/three/examples/jsm/nodes/core/BypassNode.js
var BypassNode = class extends Node_default {
  constructor(returnNode, callNode) {
    super();
    this.isBypassNode = true;
    this.outputNode = returnNode;
    this.callNode = callNode;
  }
  getNodeType(builder) {
    return this.outputNode.getNodeType(builder);
  }
  generate(builder, output) {
    const snippet = this.callNode.build(builder, "void");
    if (snippet !== "") {
      builder.addFlowCode(snippet);
    }
    return this.outputNode.build(builder, output);
  }
};
var BypassNode_default = BypassNode;

// node_modules/three/examples/jsm/nodes/core/CodeNode.js
var CodeNode = class extends Node_default {
  constructor(code2 = "", includes = []) {
    super("code");
    this.isCodeNode = true;
    this.code = code2;
    this._includes = includes;
  }
  setIncludes(includes) {
    this._includes = includes;
    return this;
  }
  getIncludes() {
    return this._includes;
  }
  generate(builder) {
    const includes = this.getIncludes(builder);
    for (const include of includes) {
      include.build(builder);
    }
    const nodeCode = builder.getCodeFromNode(this, this.getNodeType(builder));
    nodeCode.code = this.code;
    return nodeCode.code;
  }
};
var CodeNode_default = CodeNode;

// node_modules/three/examples/jsm/nodes/core/ContextNode.js
var ContextNode = class extends Node_default {
  constructor(node, context2 = {}) {
    super();
    this.isContextNode = true;
    this.node = node;
    this.context = context2;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  construct(builder) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.context });
    const node = this.node.build(builder);
    builder.setContext(previousContext);
    return node;
  }
  generate(builder, output) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.context });
    const snippet = this.node.build(builder, output);
    builder.setContext(previousContext);
    return snippet;
  }
};
var ContextNode_default = ContextNode;

// node_modules/three/examples/jsm/nodes/core/TempNode.js
var TempNode = class extends Node_default {
  constructor(type) {
    super(type);
    this.isTempNode = true;
  }
  build(builder, output) {
    const buildStage = builder.getBuildStage();
    if (buildStage === "generate") {
      const type = builder.getVectorType(this.getNodeType(builder, output));
      const nodeData = builder.getDataFromNode(this);
      if (builder.context.tempRead !== false && nodeData.propertyName !== void 0) {
        return builder.format(nodeData.propertyName, type, output);
      } else if (builder.context.tempWrite !== false && type !== "void " && output !== "void" && nodeData.dependenciesCount > 1) {
        const snippet = super.build(builder, type);
        const nodeVar = builder.getVarFromNode(this, type);
        const propertyName = builder.getPropertyName(nodeVar);
        builder.addFlowCode(`${propertyName} = ${snippet}`);
        nodeData.snippet = snippet;
        nodeData.propertyName = propertyName;
        return builder.format(nodeData.propertyName, type, output);
      }
    }
    return super.build(builder, output);
  }
};
var TempNode_default = TempNode;

// node_modules/three/examples/jsm/nodes/core/ExpressionNode.js
var ExpressionNode = class extends TempNode_default {
  constructor(snipped = "", nodeType = "void") {
    super(nodeType);
    this.snipped = snipped;
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    const snipped = this.snipped;
    if (type === "void") {
      builder.addFlowCode(snipped);
    } else {
      return `( ${snipped} )`;
    }
  }
};
var ExpressionNode_default = ExpressionNode;

// node_modules/three/examples/jsm/nodes/core/FunctionCallNode.js
var FunctionCallNode = class extends TempNode_default {
  constructor(functionNode = null, parameters = {}) {
    super();
    this.functionNode = functionNode;
    this.parameters = parameters;
  }
  setParameters(parameters) {
    this.parameters = parameters;
    return this;
  }
  getParameters() {
    return this.parameters;
  }
  getNodeType(builder) {
    return this.functionNode.getNodeType(builder);
  }
  generate(builder) {
    const params = [];
    const functionNode = this.functionNode;
    const inputs = functionNode.getInputs(builder);
    const parameters = this.parameters;
    if (Array.isArray(parameters)) {
      for (let i = 0; i < parameters.length; i++) {
        const inputNode = inputs[i];
        const node = parameters[i];
        params.push(node.build(builder, inputNode.type));
      }
    } else {
      for (const inputNode of inputs) {
        const node = parameters[inputNode.name];
        if (node !== void 0) {
          params.push(node.build(builder, inputNode.type));
        } else {
          throw new Error(`FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.`);
        }
      }
    }
    const functionName = functionNode.build(builder, "property");
    return `${functionName}( ${params.join(", ")} )`;
  }
};
var FunctionCallNode_default = FunctionCallNode;

// node_modules/three/examples/jsm/nodes/core/FunctionNode.js
var FunctionNode = class extends CodeNode_default {
  constructor(code2 = "", includes = []) {
    super(code2, includes);
    this.keywords = {};
  }
  getNodeType(builder) {
    return this.getNodeFunction(builder).type;
  }
  getInputs(builder) {
    return this.getNodeFunction(builder).inputs;
  }
  getNodeFunction(builder) {
    const nodeData = builder.getDataFromNode(this);
    let nodeFunction = nodeData.nodeFunction;
    if (nodeFunction === void 0) {
      nodeFunction = builder.parser.parseFunction(this.code);
      nodeData.nodeFunction = nodeFunction;
    }
    return nodeFunction;
  }
  call(parameters = {}) {
    return new FunctionCallNode_default(this, parameters);
  }
  generate(builder, output) {
    super.generate(builder);
    const nodeFunction = this.getNodeFunction(builder);
    const name = nodeFunction.name;
    const type = nodeFunction.type;
    const nodeCode = builder.getCodeFromNode(this, type);
    if (name !== "") {
      nodeCode.name = name;
    }
    const propertyName = builder.getPropertyName(nodeCode);
    let code2 = this.getNodeFunction(builder).getCode(propertyName);
    const keywords = this.keywords;
    const keywordsProperties = Object.keys(keywords);
    if (keywordsProperties.length > 0) {
      for (const property2 of keywordsProperties) {
        const propertyRegExp = new RegExp(`\\b${property2}\\b`, "g");
        const nodeProperty = keywords[property2].build(builder, "property");
        code2 = code2.replace(propertyRegExp, nodeProperty);
      }
    }
    nodeCode.code = code2;
    if (output === "property") {
      return propertyName;
    } else {
      return builder.format(`${propertyName}()`, type, output);
    }
  }
};
var FunctionNode_default = FunctionNode;

// node_modules/three/examples/jsm/nodes/core/InstanceIndexNode.js
var InstanceIndexNode = class extends Node_default {
  constructor() {
    super("uint");
    this.isInstanceIndexNode = true;
  }
  generate(builder) {
    return builder.getInstanceIndex();
  }
};
var InstanceIndexNode_default = InstanceIndexNode;

// node_modules/three/examples/jsm/nodes/core/PropertyNode.js
var PropertyNode = class extends Node_default {
  constructor(name = null, nodeType = "vec4") {
    super(nodeType);
    this.name = name;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  generate(builder) {
    const nodeVary = builder.getVarFromNode(this, this.getNodeType(builder));
    const name = this.name;
    if (name !== null) {
      nodeVary.name = name;
    }
    return builder.getPropertyName(nodeVary);
  }
};
var PropertyNode_default = PropertyNode;

// node_modules/three/examples/jsm/nodes/core/InputNode.js
var InputNode = class extends Node_default {
  constructor(value, nodeType = null) {
    super(nodeType);
    this.isInputNode = true;
    this.value = value;
  }
  getNodeType() {
    if (this.nodeType === null) {
      return getValueType(this.value);
    }
    return this.nodeType;
  }
  getInputType(builder) {
    return this.getNodeType(builder);
  }
  serialize(data) {
    var _a, _b;
    super.serialize(data);
    data.value = ((_b = (_a = this.value) == null ? void 0 : _a.toArray) == null ? void 0 : _b.call(_a)) || this.value;
    data.valueType = getValueType(this.value);
    data.nodeType = this.nodeType;
  }
  deserialize(data) {
    var _a, _b;
    super.deserialize(data);
    this.nodeType = data.nodeType;
    this.value = getValueFromType(data.valueType);
    this.value = ((_b = (_a = this.value) == null ? void 0 : _a.fromArray) == null ? void 0 : _b.call(_a, data.value)) || data.value;
  }
  generate() {
    console.warn("Abstract function.");
  }
};
var InputNode_default = InputNode;

// node_modules/three/examples/jsm/nodes/core/UniformNode.js
var UniformNode = class extends InputNode_default {
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isUniformNode = true;
  }
  getUniformHash(builder) {
    return this.getHash(builder);
  }
  generate(builder, output) {
    const type = this.getNodeType(builder);
    const hash = this.getUniformHash(builder);
    let sharedNode = builder.getNodeFromHash(hash);
    if (sharedNode === void 0) {
      builder.setHashNode(this, hash);
      sharedNode = this;
    }
    const sharedNodeType = sharedNode.getInputType(builder);
    const nodeUniform = builder.getUniformFromNode(sharedNode, builder.shaderStage, sharedNodeType);
    const propertyName = builder.getPropertyName(nodeUniform);
    return builder.format(propertyName, type, output);
  }
};
var UniformNode_default = UniformNode;

// node_modules/three/examples/jsm/nodes/math/OperatorNode.js
var OperatorNode = class extends TempNode_default {
  constructor(op, aNode, bNode, ...params) {
    super();
    this.op = op;
    if (params.length > 0) {
      let finalBNode = bNode;
      for (let i = 0; i < params.length; i++) {
        finalBNode = new OperatorNode(op, finalBNode, params[i]);
      }
      bNode = finalBNode;
    }
    this.aNode = aNode;
    this.bNode = bNode;
  }
  getNodeType(builder, output) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const typeA = aNode.getNodeType(builder);
    const typeB = bNode.getNodeType(builder);
    if (typeA === "void" || typeB === "void") {
      return "void";
    } else if (op === "=" || op === "%") {
      return typeA;
    } else if (op === "&" || op === "|" || op === "^" || op === ">>" || op === "<<") {
      return "int";
    } else if (op === "==" || op === "&&" || op === "||" || op === "^^") {
      return "bool";
    } else if (op === "<" || op === ">" || op === "<=" || op === ">=") {
      const typeLength = builder.getTypeLength(output);
      return typeLength > 1 ? `bvec${typeLength}` : "bool";
    } else {
      if (typeA === "float" && builder.isMatrix(typeB)) {
        return typeB;
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        return builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        return builder.getVectorFromMatrix(typeB);
      } else if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {
        return typeB;
      }
      return typeA;
    }
  }
  generate(builder, output) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const type = this.getNodeType(builder, output);
    let typeA = null;
    let typeB = null;
    if (type !== "void") {
      typeA = aNode.getNodeType(builder);
      typeB = bNode.getNodeType(builder);
      if (op === "=") {
        typeB = typeA;
      } else if (op === "<" || op === ">" || op === "<=" || op === ">=") {
        if (builder.isVector(typeA)) {
          typeB = typeA;
        } else {
          typeA = typeB = "float";
        }
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        typeB = builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        typeA = builder.getVectorFromMatrix(typeB);
      } else {
        typeA = typeB = type;
      }
    } else {
      typeA = typeB = type;
    }
    const a = aNode.build(builder, typeA);
    const b = bNode.build(builder, typeB);
    const outputLength = builder.getTypeLength(output);
    if (output !== "void") {
      if (op === "=") {
        builder.addFlowCode(`${a} ${this.op} ${b}`);
        return a;
      } else if (op === ">" && outputLength > 1) {
        return builder.format(`${builder.getMethod("greaterThan")}( ${a}, ${b} )`, type, output);
      } else if (op === "<=" && outputLength > 1) {
        return builder.format(`${builder.getMethod("lessThanEqual")}( ${a}, ${b} )`, type, output);
      } else {
        return builder.format(`( ${a} ${this.op} ${b} )`, type, output);
      }
    } else if (typeA !== "void") {
      return builder.format(`${a} ${this.op} ${b}`, type, output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.op = this.op;
  }
  deserialize(data) {
    super.deserialize(data);
    this.op = data.op;
  }
};
var OperatorNode_default = OperatorNode;

// node_modules/three/examples/jsm/nodes/core/VarNode.js
var VarNode = class extends Node_default {
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
  }
  op(op, ...params) {
    this.node = new OperatorNode_default(op, this.node, ...params);
    return this;
  }
  assign(...params) {
    return this.op("=", ...params);
  }
  add(...params) {
    return this.op("+", ...params);
  }
  sub(...params) {
    return this.op("-", ...params);
  }
  mul(...params) {
    return this.op("*", ...params);
  }
  div(...params) {
    return this.op("/", ...params);
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const node = this.node;
    const name = this.name;
    if (name === null && node.isTempNode === true) {
      return node.build(builder);
    }
    const type = builder.getVectorType(this.getNodeType(builder));
    const snippet = node.build(builder, type);
    const nodeVar = builder.getVarFromNode(this, type);
    if (name !== null) {
      nodeVar.name = name;
    }
    const propertyName = builder.getPropertyName(nodeVar);
    builder.addFlowCode(`${propertyName} = ${snippet}`);
    return propertyName;
  }
};
var VarNode_default = VarNode;

// node_modules/three/examples/jsm/nodes/accessors/BufferNode.js
var BufferNode = class extends UniformNode_default {
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType);
    this.isBufferNode = true;
    this.bufferType = bufferType;
    this.bufferCount = bufferCount;
  }
  getInputType() {
    return "buffer";
  }
};
var BufferNode_default = BufferNode;

// node_modules/three/examples/jsm/nodes/accessors/Object3DNode.js
var _Object3DNode = class extends Node_default {
  constructor(scope = _Object3DNode.VIEW_MATRIX, object3d = null) {
    super();
    this.scope = scope;
    this.object3d = object3d;
    this.updateType = NodeUpdateType.Object;
    this._uniformNode = new UniformNode_default(null);
  }
  getNodeType() {
    const scope = this.scope;
    if (scope === _Object3DNode.WORLD_MATRIX || scope === _Object3DNode.VIEW_MATRIX) {
      return "mat4";
    } else if (scope === _Object3DNode.NORMAL_MATRIX) {
      return "mat3";
    } else if (scope === _Object3DNode.POSITION || scope === _Object3DNode.VIEW_POSITION) {
      return "vec3";
    }
  }
  update(frame) {
    const object = this.object3d;
    const uniformNode = this._uniformNode;
    const scope = this.scope;
    if (scope === _Object3DNode.VIEW_MATRIX) {
      uniformNode.value = object.modelViewMatrix;
    } else if (scope === _Object3DNode.NORMAL_MATRIX) {
      uniformNode.value = object.normalMatrix;
    } else if (scope === _Object3DNode.WORLD_MATRIX) {
      uniformNode.value = object.matrixWorld;
    } else if (scope === _Object3DNode.POSITION) {
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
    } else if (scope === _Object3DNode.VIEW_POSITION) {
      const camera = frame.camera;
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
      uniformNode.value.applyMatrix4(camera.matrixWorldInverse);
    }
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === _Object3DNode.WORLD_MATRIX || scope === _Object3DNode.VIEW_MATRIX) {
      this._uniformNode.nodeType = "mat4";
    } else if (scope === _Object3DNode.NORMAL_MATRIX) {
      this._uniformNode.nodeType = "mat3";
    } else if (scope === _Object3DNode.POSITION || scope === _Object3DNode.VIEW_POSITION) {
      this._uniformNode.nodeType = "vec3";
    }
    return this._uniformNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
var Object3DNode = _Object3DNode;
__publicField(Object3DNode, "VIEW_MATRIX", "viewMatrix");
__publicField(Object3DNode, "NORMAL_MATRIX", "normalMatrix");
__publicField(Object3DNode, "WORLD_MATRIX", "worldMatrix");
__publicField(Object3DNode, "POSITION", "position");
__publicField(Object3DNode, "VIEW_POSITION", "viewPosition");
var Object3DNode_default = Object3DNode;

// node_modules/three/examples/jsm/nodes/accessors/CameraNode.js
var _CameraNode = class extends Object3DNode_default {
  constructor(scope = _CameraNode.POSITION) {
    super(scope);
  }
  getNodeType(builder) {
    const scope = this.scope;
    if (scope === _CameraNode.PROJECTION_MATRIX) {
      return "mat4";
    }
    return super.getNodeType(builder);
  }
  update(frame) {
    const camera = frame.camera;
    const uniformNode = this._uniformNode;
    const scope = this.scope;
    if (scope === _CameraNode.PROJECTION_MATRIX) {
      uniformNode.value = camera.projectionMatrix;
    } else if (scope === _CameraNode.VIEW_MATRIX) {
      uniformNode.value = camera.matrixWorldInverse;
    } else {
      this.object3d = camera;
      super.update(frame);
    }
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === _CameraNode.PROJECTION_MATRIX) {
      this._uniformNode.nodeType = "mat4";
    }
    return super.generate(builder);
  }
};
var CameraNode = _CameraNode;
__publicField(CameraNode, "PROJECTION_MATRIX", "projectionMatrix");
var CameraNode_default = CameraNode;

// node_modules/three/examples/jsm/nodes/accessors/ReferenceNode.js
var ReferenceNode = class extends Node_default {
  constructor(property2, uniformType, object = null) {
    super();
    this.property = property2;
    this.uniformType = uniformType;
    this.object = object;
    this.node = null;
    this.updateType = NodeUpdateType.Object;
    this.setNodeType(uniformType);
  }
  setNodeType(uniformType) {
    this.node = new UniformNode_default(null, uniformType);
    this.nodeType = uniformType;
    if (uniformType === "color") {
      this.nodeType = "vec3";
    } else if (uniformType === "texture") {
      this.nodeType = "vec4";
    }
  }
  getNodeType() {
    return this.uniformType;
  }
  update(frame) {
    const object = this.object !== null ? this.object : frame.object;
    const value = object[this.property];
    this.node.value = value;
  }
  generate(builder) {
    return this.node.build(builder, this.getNodeType(builder));
  }
};
var ReferenceNode_default = ReferenceNode;

// node_modules/three/examples/jsm/nodes/accessors/MaterialReferenceNode.js
var MaterialReferenceNode = class extends ReferenceNode_default {
  constructor(property2, inputType, material = null) {
    super(property2, inputType, material);
    this.material = material;
  }
  update(frame) {
    this.object = this.material !== null ? this.material : frame.material;
    super.update(frame);
  }
};
var MaterialReferenceNode_default = MaterialReferenceNode;

// node_modules/three/examples/jsm/nodes/accessors/UVNode.js
var UVNode = class extends AttributeNode_default {
  constructor(index = 0) {
    super(null, "vec2");
    this.isUVNode = true;
    this.index = index;
  }
  getAttributeName() {
    const index = this.index;
    return "uv" + (index > 0 ? index + 1 : "");
  }
  serialize(data) {
    super.serialize(data);
    data.index = this.index;
  }
  deserialize(data) {
    super.deserialize(data);
    this.index = data.index;
  }
};
var UVNode_default = UVNode;

// node_modules/three/examples/jsm/nodes/accessors/TextureNode.js
var TextureNode = class extends UniformNode_default {
  constructor(value, uvNode = new UVNode_default(), levelNode = null) {
    super(value, "vec4");
    this.isTextureNode = true;
    this.uvNode = uvNode;
    this.levelNode = levelNode;
  }
  getUniformHash() {
    return this.value.uuid;
  }
  getInputType() {
    return "texture";
  }
  generate(builder, output) {
    const texture2 = this.value;
    if (!texture2 || texture2.isTexture !== true) {
      throw new Error("TextureNode: Need a three.js texture.");
    }
    const textureProperty = super.generate(builder, "texture");
    if (output === "sampler") {
      return textureProperty + "_sampler";
    } else if (builder.isReference(output)) {
      return textureProperty;
    } else {
      const nodeData = builder.getDataFromNode(this);
      let snippet = nodeData.snippet;
      if (snippet === void 0) {
        const uvSnippet = this.uvNode.build(builder, "vec2");
        const levelNode = this.levelNode;
        if (levelNode !== null) {
          const levelSnippet = levelNode.build(builder, "float");
          snippet = builder.getTextureLevel(textureProperty, uvSnippet, levelSnippet);
        } else {
          snippet = builder.getTexture(textureProperty, uvSnippet);
        }
        nodeData.snippet = snippet;
      }
      return builder.format(snippet, "vec4", output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.value = this.value.toJSON(data.meta).uuid;
  }
  deserialize(data) {
    super.deserialize(data);
    this.value = data.meta.textures[data.value];
  }
};
var TextureNode_default = TextureNode;

// node_modules/three/examples/jsm/nodes/core/NodeBuilder.js
var defaultShaderStages = ["fragment", "vertex"];
var shaderStages = [...defaultShaderStages, "compute"];
var vector = ["x", "y", "z", "w"];
var typeFromLength = /* @__PURE__ */ new Map();
typeFromLength.set(1, "float");
typeFromLength.set(2, "vec2");
typeFromLength.set(3, "vec3");
typeFromLength.set(4, "vec4");
typeFromLength.set(9, "mat3");
typeFromLength.set(16, "mat4");

// node_modules/three/examples/jsm/nodes/utils/SplitNode.js
var vectorComponents = "xyzw";
var SplitNode = class extends Node_default {
  constructor(node, components = "x") {
    super();
    this.node = node;
    this.components = components;
  }
  getVectorLength() {
    let vectorLength = this.components.length;
    for (const c of this.components) {
      vectorLength = Math.max(vector.indexOf(c) + 1, vectorLength);
    }
    return vectorLength;
  }
  getNodeType(builder) {
    return builder.getTypeFromLength(this.components.length);
  }
  generate(builder, output) {
    const node = this.node;
    const nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));
    let snippet = null;
    if (nodeTypeLength > 1) {
      let type = null;
      const componentsLength = this.getVectorLength();
      if (componentsLength >= nodeTypeLength) {
        type = builder.getTypeFromLength(this.getVectorLength());
      }
      const nodeSnippet = node.build(builder, type);
      if (this.components.length === nodeTypeLength && this.components === vectorComponents.slice(0, this.components.length)) {
        snippet = builder.format(nodeSnippet, type, output);
      } else {
        snippet = builder.format(`${nodeSnippet}.${this.components}`, this.getNodeType(builder), output);
      }
    } else {
      snippet = node.build(builder, output);
    }
    return snippet;
  }
  serialize(data) {
    super.serialize(data);
    data.components = this.components;
  }
  deserialize(data) {
    super.deserialize(data);
    this.components = data.components;
  }
};
var SplitNode_default = SplitNode;

// node_modules/three/examples/jsm/nodes/accessors/MaterialNode.js
var _MaterialNode = class extends Node_default {
  constructor(scope = _MaterialNode.COLOR) {
    super();
    this.scope = scope;
  }
  getNodeType(builder) {
    const scope = this.scope;
    const material = builder.context.material;
    if (scope === _MaterialNode.COLOR) {
      return material.map !== null ? "vec4" : "vec3";
    } else if (scope === _MaterialNode.OPACITY || scope === _MaterialNode.ROTATION) {
      return "float";
    } else if (scope === _MaterialNode.EMISSIVE) {
      return "vec3";
    } else if (scope === _MaterialNode.ROUGHNESS || scope === _MaterialNode.METALNESS) {
      return "float";
    }
  }
  generate(builder, output) {
    var _a, _b, _c, _d, _e;
    const material = builder.context.material;
    const scope = this.scope;
    let node = null;
    if (scope === _MaterialNode.ALPHA_TEST) {
      node = new MaterialReferenceNode_default("alphaTest", "float");
    } else if (scope === _MaterialNode.COLOR) {
      const colorNode = new MaterialReferenceNode_default("color", "color");
      if (((_a = material.map) == null ? void 0 : _a.isTexture) === true) {
        const map = new TextureNode_default(material.map);
        node = new OperatorNode_default("*", colorNode, map);
      } else {
        node = colorNode;
      }
    } else if (scope === _MaterialNode.OPACITY) {
      const opacityNode = new MaterialReferenceNode_default("opacity", "float");
      if (((_b = material.alphaMap) == null ? void 0 : _b.isTexture) === true) {
        node = new OperatorNode_default("*", opacityNode, new MaterialReferenceNode_default("alphaMap", "texture"));
      } else {
        node = opacityNode;
      }
    } else if (scope === _MaterialNode.ROUGHNESS) {
      const roughnessNode = new MaterialReferenceNode_default("roughness", "float");
      if (((_c = material.roughnessMap) == null ? void 0 : _c.isTexture) === true) {
        node = new OperatorNode_default("*", roughnessNode, new SplitNode_default(new TextureNode_default(material.roughnessMap), "g"));
      } else {
        node = roughnessNode;
      }
    } else if (scope === _MaterialNode.METALNESS) {
      const metalnessNode = new MaterialReferenceNode_default("metalness", "float");
      if (((_d = material.metalnessMap) == null ? void 0 : _d.isTexture) === true) {
        node = new OperatorNode_default("*", metalnessNode, new SplitNode_default(new TextureNode_default(material.metalnessMap), "b"));
      } else {
        node = metalnessNode;
      }
    } else if (scope === _MaterialNode.EMISSIVE) {
      const emissiveNode = new MaterialReferenceNode_default("emissive", "color");
      if (((_e = material.emissiveMap) == null ? void 0 : _e.isTexture) === true) {
        node = new OperatorNode_default("*", emissiveNode, new TextureNode_default(material.emissiveMap));
      } else {
        node = emissiveNode;
      }
    } else if (scope === _MaterialNode.ROTATION) {
      node = new MaterialReferenceNode_default("rotation", "float");
    } else {
      const outputType = this.getNodeType(builder);
      node = new MaterialReferenceNode_default(scope, outputType);
    }
    return node.build(builder, output);
  }
};
var MaterialNode = _MaterialNode;
__publicField(MaterialNode, "ALPHA_TEST", "alphaTest");
__publicField(MaterialNode, "COLOR", "color");
__publicField(MaterialNode, "OPACITY", "opacity");
__publicField(MaterialNode, "ROUGHNESS", "roughness");
__publicField(MaterialNode, "METALNESS", "metalness");
__publicField(MaterialNode, "EMISSIVE", "emissive");
__publicField(MaterialNode, "ROTATION", "rotation");
var MaterialNode_default = MaterialNode;

// node_modules/three/examples/jsm/nodes/accessors/ModelNode.js
var ModelNode = class extends Object3DNode_default {
  constructor(scope = ModelNode.VIEW_MATRIX) {
    super(scope);
  }
  update(frame) {
    this.object3d = frame.object;
    super.update(frame);
  }
};
var ModelNode_default = ModelNode;

// node_modules/three/examples/jsm/nodes/math/MathNode.js
var _MathNode = class extends TempNode_default {
  constructor(method, aNode, bNode = null, cNode = null) {
    super();
    this.method = method;
    this.aNode = aNode;
    this.bNode = bNode;
    this.cNode = cNode;
  }
  getInputType(builder) {
    const aType = this.aNode.getNodeType(builder);
    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;
    const cType = this.cNode ? this.cNode.getNodeType(builder) : null;
    const aLen = builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);
    const bLen = builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);
    const cLen = builder.isMatrix(cType) ? 0 : builder.getTypeLength(cType);
    if (aLen > bLen && aLen > cLen) {
      return aType;
    } else if (bLen > cLen) {
      return bType;
    } else if (cLen > aLen) {
      return cType;
    }
    return aType;
  }
  getNodeType(builder) {
    const method = this.method;
    if (method === _MathNode.LENGTH || method === _MathNode.DISTANCE || method === _MathNode.DOT) {
      return "float";
    } else if (method === _MathNode.CROSS) {
      return "vec3";
    } else {
      return this.getInputType(builder);
    }
  }
  generate(builder, output) {
    const method = this.method;
    const type = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a = this.aNode;
    const b = this.bNode;
    const c = this.cNode;
    const isWebGL = builder.renderer.isWebGLRenderer === true;
    if (method === _MathNode.TRANSFORM_DIRECTION) {
      let tA = a;
      let tB = b;
      if (builder.isMatrix(tA.getNodeType(builder))) {
        tB = new ExpressionNode_default(`${builder.getType("vec4")}( ${tB.build(builder, "vec3")}, 0.0 )`, "vec4");
      } else {
        tA = new ExpressionNode_default(`${builder.getType("vec4")}( ${tA.build(builder, "vec3")}, 0.0 )`, "vec4");
      }
      const mulNode = new SplitNode_default(new OperatorNode_default("*", tA, tB), "xyz");
      return new _MathNode(_MathNode.NORMALIZE, mulNode).build(builder);
    } else if (method === _MathNode.SATURATE) {
      return builder.format(`clamp( ${a.build(builder, inputType)}, 0.0, 1.0 )`, type, output);
    } else if (method === _MathNode.NEGATE) {
      return builder.format("( -" + a.build(builder, inputType) + " )", type, output);
    } else if (method === _MathNode.INVERT) {
      return builder.format("( 1.0 - " + a.build(builder, inputType) + " )", type, output);
    } else {
      const params = [];
      if (method === _MathNode.CROSS) {
        params.push(
          a.build(builder, type),
          b.build(builder, type)
        );
      } else if (method === _MathNode.STEP) {
        params.push(
          a.build(builder, builder.getTypeLength(a.getNodeType(builder)) === 1 ? "float" : inputType),
          b.build(builder, inputType)
        );
      } else if (isWebGL && (method === _MathNode.MIN || method === _MathNode.MAX) || method === _MathNode.MOD) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, builder.getTypeLength(b.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else if (method === _MathNode.REFRACT) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c.build(builder, "float")
        );
      } else if (method === _MathNode.MIX) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c.build(builder, builder.getTypeLength(c.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else {
        params.push(a.build(builder, inputType));
        if (c !== null) {
          params.push(b.build(builder, inputType), c.build(builder, inputType));
        } else if (b !== null) {
          params.push(b.build(builder, inputType));
        }
      }
      return builder.format(`${builder.getMethod(method)}( ${params.join(", ")} )`, type, output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
var MathNode = _MathNode;
__publicField(MathNode, "RADIANS", "radians");
__publicField(MathNode, "DEGREES", "degrees");
__publicField(MathNode, "EXP", "exp");
__publicField(MathNode, "EXP2", "exp2");
__publicField(MathNode, "LOG", "log");
__publicField(MathNode, "LOG2", "log2");
__publicField(MathNode, "SQRT", "sqrt");
__publicField(MathNode, "INVERSE_SQRT", "inversesqrt");
__publicField(MathNode, "FLOOR", "floor");
__publicField(MathNode, "CEIL", "ceil");
__publicField(MathNode, "NORMALIZE", "normalize");
__publicField(MathNode, "FRACT", "fract");
__publicField(MathNode, "SIN", "sin");
__publicField(MathNode, "COS", "cos");
__publicField(MathNode, "TAN", "tan");
__publicField(MathNode, "ASIN", "asin");
__publicField(MathNode, "ACOS", "acos");
__publicField(MathNode, "ATAN", "atan");
__publicField(MathNode, "ABS", "abs");
__publicField(MathNode, "SIGN", "sign");
__publicField(MathNode, "LENGTH", "length");
__publicField(MathNode, "NEGATE", "negate");
__publicField(MathNode, "INVERT", "invert");
__publicField(MathNode, "DFDX", "dFdx");
__publicField(MathNode, "DFDY", "dFdy");
__publicField(MathNode, "SATURATE", "saturate");
__publicField(MathNode, "ROUND", "round");
__publicField(MathNode, "ATAN2", "atan2");
__publicField(MathNode, "MIN", "min");
__publicField(MathNode, "MAX", "max");
__publicField(MathNode, "MOD", "mod");
__publicField(MathNode, "STEP", "step");
__publicField(MathNode, "REFLECT", "reflect");
__publicField(MathNode, "DISTANCE", "distance");
__publicField(MathNode, "DOT", "dot");
__publicField(MathNode, "CROSS", "cross");
__publicField(MathNode, "POW", "pow");
__publicField(MathNode, "TRANSFORM_DIRECTION", "transformDirection");
__publicField(MathNode, "MIX", "mix");
__publicField(MathNode, "CLAMP", "clamp");
__publicField(MathNode, "REFRACT", "refract");
__publicField(MathNode, "SMOOTHSTEP", "smoothstep");
__publicField(MathNode, "FACEFORWARD", "faceforward");
var MathNode_default = MathNode;

// node_modules/three/examples/jsm/nodes/accessors/PositionNode.js
var _PositionNode = class extends Node_default {
  constructor(scope = _PositionNode.LOCAL) {
    super("vec3");
    this.scope = scope;
  }
  getHash() {
    return `position-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    let outputNode = null;
    if (scope === _PositionNode.GEOMETRY) {
      outputNode = new AttributeNode_default("position", "vec3");
    } else if (scope === _PositionNode.LOCAL) {
      outputNode = new VaryingNode_default(new _PositionNode(_PositionNode.GEOMETRY));
    } else if (scope === _PositionNode.WORLD) {
      const vertexPositionNode = new MathNode_default(MathNode_default.TRANSFORM_DIRECTION, new ModelNode_default(ModelNode_default.WORLD_MATRIX), new _PositionNode(_PositionNode.LOCAL));
      outputNode = new VaryingNode_default(vertexPositionNode);
    } else if (scope === _PositionNode.VIEW) {
      const vertexPositionNode = new OperatorNode_default("*", new ModelNode_default(ModelNode_default.VIEW_MATRIX), new _PositionNode(_PositionNode.LOCAL));
      outputNode = new VaryingNode_default(vertexPositionNode);
    } else if (scope === _PositionNode.VIEW_DIRECTION) {
      const vertexPositionNode = new MathNode_default(MathNode_default.NEGATE, new _PositionNode(_PositionNode.VIEW));
      outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryingNode_default(vertexPositionNode));
    }
    return outputNode.build(builder, this.getNodeType(builder));
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
var PositionNode = _PositionNode;
__publicField(PositionNode, "GEOMETRY", "geometry");
__publicField(PositionNode, "LOCAL", "local");
__publicField(PositionNode, "WORLD", "world");
__publicField(PositionNode, "VIEW", "view");
__publicField(PositionNode, "VIEW_DIRECTION", "viewDirection");
var PositionNode_default = PositionNode;

// node_modules/three/examples/jsm/nodes/accessors/ModelViewProjectionNode.js
var ModelViewProjectionNode = class extends Node_default {
  constructor(position = new PositionNode_default()) {
    super("vec4");
    this.position = position;
  }
  generate(builder) {
    const position = this.position;
    const mvpMatrix = new OperatorNode_default("*", new CameraNode_default(CameraNode_default.PROJECTION_MATRIX), new ModelNode_default(ModelNode_default.VIEW_MATRIX));
    const mvpNode = new OperatorNode_default("*", mvpMatrix, position);
    return mvpNode.build(builder);
  }
};
var ModelViewProjectionNode_default = ModelViewProjectionNode;

// node_modules/three/examples/jsm/nodes/accessors/NormalNode.js
var _NormalNode = class extends Node_default {
  constructor(scope = _NormalNode.LOCAL) {
    super("vec3");
    this.scope = scope;
  }
  getHash() {
    return `normal-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    let outputNode = null;
    if (scope === _NormalNode.GEOMETRY) {
      outputNode = new AttributeNode_default("normal", "vec3");
    } else if (scope === _NormalNode.LOCAL) {
      outputNode = new VaryingNode_default(new _NormalNode(_NormalNode.GEOMETRY));
    } else if (scope === _NormalNode.VIEW) {
      const vertexNormalNode = new OperatorNode_default("*", new ModelNode_default(ModelNode_default.NORMAL_MATRIX), new _NormalNode(_NormalNode.LOCAL));
      outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryingNode_default(vertexNormalNode));
    } else if (scope === _NormalNode.WORLD) {
      const vertexNormalNode = new MathNode_default(MathNode_default.TRANSFORM_DIRECTION, new _NormalNode(_NormalNode.VIEW), new CameraNode_default(CameraNode_default.VIEW_MATRIX));
      outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryingNode_default(vertexNormalNode));
    }
    return outputNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
var NormalNode = _NormalNode;
__publicField(NormalNode, "GEOMETRY", "geometry");
__publicField(NormalNode, "LOCAL", "local");
__publicField(NormalNode, "WORLD", "world");
__publicField(NormalNode, "VIEW", "view");
var NormalNode_default = NormalNode;

// node_modules/three/examples/jsm/nodes/accessors/PointUVNode.js
var PointUVNode = class extends Node_default {
  constructor() {
    super("vec2");
    this.isPointUVNode = true;
  }
  generate() {
    return "vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )";
  }
};
var PointUVNode_default = PointUVNode;

// node_modules/three/examples/jsm/nodes/accessors/StorageBufferNode.js
var StorageBufferNode = class extends BufferNode_default {
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType, bufferCount);
    this.isStorageBufferNode = true;
  }
  getInputType() {
    return "storageBuffer";
  }
};
var StorageBufferNode_default = StorageBufferNode;

// node_modules/three/examples/jsm/nodes/accessors/UserDataNode.js
var UserDataNode = class extends ReferenceNode_default {
  constructor(property2, inputType, userData2 = null) {
    super(property2, inputType, userData2);
    this.userData = userData2;
  }
  update(frame) {
    this.object = this.userData !== null ? this.userData : frame.object.userData;
    super.update(frame);
  }
};
var UserDataNode_default = UserDataNode;

// node_modules/three/examples/jsm/nodes/display/FrontFacingNode.js
var FrontFacingNode = class extends Node_default {
  constructor() {
    super("bool");
    this.isFrontFacingNode = true;
  }
  generate(builder) {
    return builder.getFrontFacing();
  }
};
var FrontFacingNode_default = FrontFacingNode;

// node_modules/three/examples/jsm/nodes/gpgpu/ComputeNode.js
var ComputeNode = class extends Node_default {
  constructor(computeNode, count, workgroupSize = [64]) {
    super("void");
    this.isComputeNode = true;
    this.computeNode = computeNode;
    this.count = count;
    this.workgroupSize = workgroupSize;
    this.dispatchCount = 0;
    this.updateType = NodeUpdateType.Object;
    this.updateDispatchCount();
  }
  updateDispatchCount() {
    const { count, workgroupSize } = this;
    let size = workgroupSize[0];
    for (let i = 1; i < workgroupSize.length; i++)
      size *= workgroupSize[i];
    this.dispatchCount = Math.ceil(count / size);
  }
  onInit() {
  }
  update({ renderer }) {
    renderer.compute(this);
  }
  generate(builder) {
    const { shaderStage } = builder;
    if (shaderStage === "compute") {
      const snippet = this.computeNode.build(builder, "void");
      if (snippet !== "") {
        builder.addFlowCode(snippet);
      }
    }
  }
};
var ComputeNode_default = ComputeNode;

// node_modules/three/examples/jsm/nodes/math/CondNode.js
var CondNode = class extends Node_default {
  constructor(condNode, ifNode, elseNode) {
    super();
    this.condNode = condNode;
    this.ifNode = ifNode;
    this.elseNode = elseNode;
  }
  getNodeType(builder) {
    const ifType = this.ifNode.getNodeType(builder);
    const elseType = this.elseNode.getNodeType(builder);
    if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {
      return elseType;
    }
    return ifType;
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    const context2 = { tempWrite: false };
    const nodeProperty = new PropertyNode_default(null, type).build(builder);
    const nodeSnippet = new ContextNode_default(this.condNode).build(builder, "bool"), ifSnippet = new ContextNode_default(this.ifNode, context2).build(builder, type), elseSnippet = new ContextNode_default(this.elseNode, context2).build(builder, type);
    builder.addFlowCode(`if ( ${nodeSnippet} ) {

		${nodeProperty} = ${ifSnippet};

	} else {

		${nodeProperty} = ${elseSnippet};

	}`);
    return nodeProperty;
  }
};
var CondNode_default = CondNode;

// node_modules/three/examples/jsm/nodes/utils/ArrayElementNode.js
var ArrayElementNode = class extends Node_default {
  constructor(node, indexNode) {
    super();
    this.node = node;
    this.indexNode = indexNode;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const nodeSnippet = this.node.build(builder);
    const indexSnippet = this.indexNode.build(builder, "uint");
    return `${nodeSnippet}[ ${indexSnippet} ]`;
  }
};
var ArrayElementNode_default = ArrayElementNode;

// node_modules/three/examples/jsm/nodes/utils/ConvertNode.js
var ConvertNode = class extends Node_default {
  constructor(node, convertTo) {
    super();
    this.node = node;
    this.convertTo = convertTo;
  }
  getNodeType() {
    return this.convertTo;
  }
  generate(builder, output) {
    const convertTo = this.convertTo;
    const node = this.node;
    const type = this.getNodeType(builder);
    let snippet = null;
    if (builder.isReference(convertTo) === false) {
      const nodeSnippet = node.build(builder, convertTo);
      snippet = builder.format(nodeSnippet, type, convertTo);
    } else {
      snippet = node.build(builder, convertTo);
    }
    return builder.format(snippet, type, output);
  }
};
var ConvertNode_default = ConvertNode;

// node_modules/three/examples/jsm/nodes/utils/JoinNode.js
var JoinNode = class extends Node_default {
  constructor(nodes = []) {
    super();
    this.nodes = nodes;
  }
  getNodeType(builder) {
    return builder.getTypeFromLength(this.nodes.reduce((count, cur) => count + builder.getTypeLength(cur.getNodeType(builder)), 0));
  }
  generate(builder, output) {
    const type = this.getNodeType(builder);
    const nodes = this.nodes;
    const snippetValues = [];
    for (const input of nodes) {
      const inputSnippet = input.build(builder);
      snippetValues.push(inputSnippet);
    }
    const snippet = `${builder.getType(type)}( ${snippetValues.join(", ")} )`;
    return builder.format(snippet, type, output);
  }
};
var JoinNode_default = JoinNode;

// node_modules/three/examples/jsm/nodes/core/ConstNode.js
var ConstNode = class extends InputNode_default {
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isConstNode = true;
  }
  generateConst(builder) {
    return builder.getConst(this.getNodeType(builder), this.value);
  }
  generate(builder, output) {
    const type = this.getNodeType(builder);
    return builder.format(this.generateConst(builder), type, output);
  }
};
var ConstNode_default = ConstNode;

// node_modules/three/examples/jsm/nodes/shadernode/ShaderNode.js
var shaderNodeHandler = {
  construct(NodeClosure, params) {
    const inputs = params.shift();
    return NodeClosure(nodeObjects(inputs), ...params);
  },
  get: function(node, prop) {
    if (typeof prop === "string" && node[prop] === void 0) {
      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {
        prop = prop.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w");
        return nodeObject(new SplitNode_default(node, prop));
      } else if (/^\d+$/.test(prop) === true) {
        return nodeObject(new ArrayElementNode_default(node, new ConstNode_default(Number(prop), "uint")));
      }
    }
    return node[prop];
  }
};
var nodeObjectsCacheMap = /* @__PURE__ */ new WeakMap();
var ShaderNodeObject = function(obj) {
  const type = typeof obj;
  if (type === "number" || type === "boolean") {
    return nodeObject(getAutoTypedConstNode(obj));
  } else if (type === "object") {
    if ((obj == null ? void 0 : obj.isNode) === true) {
      let nodeObject2 = nodeObjectsCacheMap.get(obj);
      if (nodeObject2 === void 0) {
        nodeObject2 = new Proxy(obj, shaderNodeHandler);
        nodeObjectsCacheMap.set(obj, nodeObject2);
        nodeObjectsCacheMap.set(nodeObject2, nodeObject2);
      }
      return nodeObject2;
    }
  }
  return obj;
};
var ShaderNodeObjects = function(objects) {
  for (const name in objects) {
    objects[name] = nodeObject(objects[name]);
  }
  return objects;
};
var ShaderNodeArray = function(array) {
  const len = array.length;
  for (let i = 0; i < len; i++) {
    array[i] = nodeObject(array[i]);
  }
  return array;
};
var ShaderNodeProxy = function(NodeClass, scope = null, factor = null) {
  if (scope === null) {
    return (...params) => {
      return nodeObject(new NodeClass(...nodeArray(params)));
    };
  } else if (factor === null) {
    return (...params) => {
      return nodeObject(new NodeClass(scope, ...nodeArray(params)));
    };
  } else {
    factor = nodeObject(factor);
    return (...params) => {
      return nodeObject(new NodeClass(scope, ...nodeArray(params), factor));
    };
  }
};
var ShaderNodeImmutable = function(NodeClass, ...params) {
  return nodeObject(new NodeClass(...nodeArray(params)));
};
var ShaderNodeScript = function(jsFunc) {
  const self = {
    build: (builder) => {
      self.call({}, builder);
      return "";
    },
    call: (inputs, builder) => {
      inputs = nodeObjects(inputs);
      return nodeObject(jsFunc(inputs, builder));
    }
  };
  return self;
};
var ShaderNode = new Proxy(ShaderNodeScript, shaderNodeHandler);
var nodeObject = (val) => ShaderNodeObject(val);
var nodeObjects = (val) => new ShaderNodeObjects(val);
var nodeArray = (val) => new ShaderNodeArray(val);
var nodeProxy = (...val) => new ShaderNodeProxy(...val);
var nodeImmutable = (...val) => new ShaderNodeImmutable(...val);
var bools = [false, true];
var uints = [0, 1, 2, 3];
var ints = [-1, -2];
var floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];
var boolsCacheMap = /* @__PURE__ */ new Map();
for (const bool2 of bools)
  boolsCacheMap.set(bool2, new ConstNode_default(bool2));
var uintsCacheMap = /* @__PURE__ */ new Map();
for (const uint2 of uints)
  uintsCacheMap.set(uint2, new ConstNode_default(uint2, "uint"));
var intsCacheMap = new Map([...uintsCacheMap].map((el) => new ConstNode_default(el.value, "int")));
for (const int2 of ints)
  intsCacheMap.set(int2, new ConstNode_default(int2, "int"));
var floatsCacheMap = new Map([...intsCacheMap].map((el) => new ConstNode_default(el.value)));
for (const float2 of floats)
  floatsCacheMap.set(float2, new ConstNode_default(float2));
for (const float2 of floats)
  floatsCacheMap.set(-float2, new ConstNode_default(-float2));
var cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };
var constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);
var getAutoTypedConstNode = (value) => {
  if (constNodesCacheMap.has(value)) {
    return constNodesCacheMap.get(value);
  } else if (value.isNode === true) {
    return value;
  } else {
    return new ConstNode_default(value);
  }
};
var ConvertType = function(type, cacheMap = null) {
  return (...params) => {
    if (params.length === 0) {
      return nodeObject(new ConstNode_default(getValueFromType(type), type));
    } else {
      if (type === "color" && params[0].isNode !== true) {
        params = [getValueFromType(type, ...params)];
      }
      if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {
        return cacheMap.get(params[0]);
      }
      const nodes = params.map(getAutoTypedConstNode);
      if (nodes.length === 1) {
        return nodeObject(nodes[0].nodeType === type ? nodes[0] : new ConvertNode_default(nodes[0], type));
      }
      return nodeObject(new ConvertNode_default(new JoinNode_default(nodes), type));
    }
  };
};
var getConstNodeType = (value) => value.nodeType || value.convertTo || (typeof value === "string" ? value : null);

// node_modules/three/examples/jsm/nodes/shadernode/ShaderNodeBaseElements.js
var color = new ConvertType("color");
var float = new ConvertType("float", cacheMaps.float);
var int = new ConvertType("int", cacheMaps.int);
var uint = new ConvertType("uint", cacheMaps.uint);
var bool = new ConvertType("bool", cacheMaps.bool);
var vec2 = new ConvertType("vec2");
var ivec2 = new ConvertType("ivec2");
var uvec2 = new ConvertType("uvec2");
var bvec2 = new ConvertType("bvec2");
var vec3 = new ConvertType("vec3");
var ivec3 = new ConvertType("ivec3");
var uvec3 = new ConvertType("uvec3");
var bvec3 = new ConvertType("bvec3");
var vec4 = new ConvertType("vec4");
var ivec4 = new ConvertType("ivec4");
var uvec4 = new ConvertType("uvec4");
var bvec4 = new ConvertType("bvec4");
var mat3 = new ConvertType("mat3");
var imat3 = new ConvertType("imat3");
var umat3 = new ConvertType("umat3");
var bmat3 = new ConvertType("bmat3");
var mat4 = new ConvertType("mat4");
var imat4 = new ConvertType("imat4");
var umat4 = new ConvertType("umat4");
var bmat4 = new ConvertType("bmat4");
var func = (code2, includes) => {
  const node = nodeObject(new FunctionNode_default(code2, includes));
  const call2 = node.call.bind(node);
  node.call = (...params) => {
    var _a;
    return nodeObject(call2(params.length > 1 || ((_a = params[0]) == null ? void 0 : _a.isNode) === true ? nodeArray(params) : nodeObjects(params[0])));
  };
  return node;
};
var uniform = (nodeOrType) => {
  var _a;
  const nodeType = getConstNodeType(nodeOrType);
  const value = nodeOrType.isNode === true ? ((_a = nodeOrType.node) == null ? void 0 : _a.value) || nodeOrType.value : nodeOrType;
  return nodeObject(new UniformNode_default(value, nodeType));
};
var fn = (code2, includes) => func(code2, includes).call;
var attribute = (name, nodeType) => nodeObject(new AttributeNode_default(name, nodeType));
var property = (name, nodeOrType) => nodeObject(new PropertyNode_default(name, getConstNodeType(nodeOrType)));
var bypass = nodeProxy(BypassNode_default);
var code = nodeProxy(CodeNode_default);
var context = nodeProxy(ContextNode_default);
var expression = nodeProxy(ExpressionNode_default);
var call = nodeProxy(FunctionCallNode_default);
var instanceIndex = nodeImmutable(InstanceIndexNode_default);
var label = nodeProxy(VarNode_default);
var temp = label;
var varying = nodeProxy(VaryingNode_default);
var buffer = (value, nodeOrType, count) => nodeObject(new BufferNode_default(value, getConstNodeType(nodeOrType), count));
var storage = (value, nodeOrType, count) => nodeObject(new StorageBufferNode_default(value, getConstNodeType(nodeOrType), count));
var cameraProjectionMatrix = nodeImmutable(CameraNode_default, CameraNode_default.PROJECTION_MATRIX);
var cameraViewMatrix = nodeImmutable(CameraNode_default, CameraNode_default.VIEW_MATRIX);
var cameraNormalMatrix = nodeImmutable(CameraNode_default, CameraNode_default.NORMAL_MATRIX);
var cameraWorldMatrix = nodeImmutable(CameraNode_default, CameraNode_default.WORLD_MATRIX);
var cameraPosition = nodeImmutable(CameraNode_default, CameraNode_default.POSITION);
var materialAlphaTest = nodeImmutable(MaterialNode_default, MaterialNode_default.ALPHA_TEST);
var materialColor = nodeImmutable(MaterialNode_default, MaterialNode_default.COLOR);
var materialEmissive = nodeImmutable(MaterialNode_default, MaterialNode_default.EMISSIVE);
var materialOpacity = nodeImmutable(MaterialNode_default, MaterialNode_default.OPACITY);
var materialRoughness = nodeImmutable(MaterialNode_default, MaterialNode_default.ROUGHNESS);
var materialMetalness = nodeImmutable(MaterialNode_default, MaterialNode_default.METALNESS);
var materialRotation = nodeImmutable(MaterialNode_default, MaterialNode_default.ROTATION);
var diffuseColor = nodeImmutable(PropertyNode_default, "DiffuseColor", "vec4");
var roughness = nodeImmutable(PropertyNode_default, "Roughness", "float");
var metalness = nodeImmutable(PropertyNode_default, "Metalness", "float");
var alphaTest = nodeImmutable(PropertyNode_default, "AlphaTest", "float");
var specularColor = nodeImmutable(PropertyNode_default, "SpecularColor", "color");
var reference = (name, nodeOrType, object) => nodeObject(new ReferenceNode_default(name, getConstNodeType(nodeOrType), object));
var materialReference = (name, nodeOrType, material) => nodeObject(new MaterialReferenceNode_default(name, getConstNodeType(nodeOrType), material));
var userData = (name, inputType, userData2) => nodeObject(new UserDataNode_default(name, inputType, userData2));
var modelViewProjection = nodeProxy(ModelViewProjectionNode_default);
var normalGeometry = nodeImmutable(NormalNode_default, NormalNode_default.GEOMETRY);
var normalLocal = nodeImmutable(NormalNode_default, NormalNode_default.LOCAL);
var normalWorld = nodeImmutable(NormalNode_default, NormalNode_default.WORLD);
var normalView = nodeImmutable(NormalNode_default, NormalNode_default.VIEW);
var transformedNormalView = nodeImmutable(VarNode_default, normalView, "TransformedNormalView");
var modelViewMatrix = nodeImmutable(ModelNode_default, ModelNode_default.VIEW_MATRIX);
var modelNormalMatrix = nodeImmutable(ModelNode_default, ModelNode_default.NORMAL_MATRIX);
var modelWorldMatrix = nodeImmutable(ModelNode_default, ModelNode_default.WORLD_MATRIX);
var modelPosition = nodeImmutable(ModelNode_default, ModelNode_default.POSITION);
var modelViewPosition = nodeImmutable(ModelNode_default, ModelNode_default.VIEW_POSITION);
var positionGeometry = nodeImmutable(PositionNode_default, PositionNode_default.GEOMETRY);
var positionLocal = nodeImmutable(PositionNode_default, PositionNode_default.LOCAL);
var positionWorld = nodeImmutable(PositionNode_default, PositionNode_default.WORLD);
var positionView = nodeImmutable(PositionNode_default, PositionNode_default.VIEW);
var positionViewDirection = nodeImmutable(PositionNode_default, PositionNode_default.VIEW_DIRECTION);
var texture = nodeProxy(TextureNode_default);
var sampler = (texture2) => nodeObject(new ConvertNode_default(texture2.isNode === true ? texture2 : new TextureNode_default(texture2), "sampler"));
var uv = (...params) => nodeObject(new UVNode_default(...params));
var pointUV = nodeImmutable(PointUVNode_default);
var compute = (node, count, workgroupSize) => nodeObject(new ComputeNode_default(nodeObject(node), count, workgroupSize));
var EPSILON = float(1e-6);
var INFINITY = float(1e6);
var cond = nodeProxy(CondNode_default);
var add = nodeProxy(OperatorNode_default, "+");
var sub = nodeProxy(OperatorNode_default, "-");
var mul = nodeProxy(OperatorNode_default, "*");
var div = nodeProxy(OperatorNode_default, "/");
var remainder = nodeProxy(OperatorNode_default, "%");
var equal = nodeProxy(OperatorNode_default, "==");
var assign = nodeProxy(OperatorNode_default, "=");
var lessThan = nodeProxy(OperatorNode_default, "<");
var greaterThan = nodeProxy(OperatorNode_default, ">");
var lessThanEqual = nodeProxy(OperatorNode_default, "<=");
var greaterThanEqual = nodeProxy(OperatorNode_default, ">=");
var and = nodeProxy(OperatorNode_default, "&&");
var or = nodeProxy(OperatorNode_default, "||");
var xor = nodeProxy(OperatorNode_default, "^^");
var bitAnd = nodeProxy(OperatorNode_default, "&");
var bitOr = nodeProxy(OperatorNode_default, "|");
var bitXor = nodeProxy(OperatorNode_default, "^");
var shiftLeft = nodeProxy(OperatorNode_default, "<<");
var shiftRight = nodeProxy(OperatorNode_default, ">>");
var radians = nodeProxy(MathNode_default, MathNode_default.RADIANS);
var degrees = nodeProxy(MathNode_default, MathNode_default.DEGREES);
var exp = nodeProxy(MathNode_default, MathNode_default.EXP);
var exp2 = nodeProxy(MathNode_default, MathNode_default.EXP2);
var log = nodeProxy(MathNode_default, MathNode_default.LOG);
var log2 = nodeProxy(MathNode_default, MathNode_default.LOG2);
var sqrt = nodeProxy(MathNode_default, MathNode_default.SQRT);
var inversesqrt = nodeProxy(MathNode_default, MathNode_default.INVERSE_SQRT);
var floor = nodeProxy(MathNode_default, MathNode_default.FLOOR);
var ceil = nodeProxy(MathNode_default, MathNode_default.CEIL);
var normalize = nodeProxy(MathNode_default, MathNode_default.NORMALIZE);
var fract = nodeProxy(MathNode_default, MathNode_default.FRACT);
var sin = nodeProxy(MathNode_default, MathNode_default.SIN);
var cos = nodeProxy(MathNode_default, MathNode_default.COS);
var tan = nodeProxy(MathNode_default, MathNode_default.TAN);
var asin = nodeProxy(MathNode_default, MathNode_default.ASIN);
var acos = nodeProxy(MathNode_default, MathNode_default.ACOS);
var atan = nodeProxy(MathNode_default, MathNode_default.ATAN);
var abs = nodeProxy(MathNode_default, MathNode_default.ABS);
var sign = nodeProxy(MathNode_default, MathNode_default.SIGN);
var length = nodeProxy(MathNode_default, MathNode_default.LENGTH);
var negate = nodeProxy(MathNode_default, MathNode_default.NEGATE);
var invert = nodeProxy(MathNode_default, MathNode_default.INVERT);
var dFdx = nodeProxy(MathNode_default, MathNode_default.DFDX);
var dFdy = nodeProxy(MathNode_default, MathNode_default.DFDY);
var saturate = nodeProxy(MathNode_default, MathNode_default.SATURATE);
var round = nodeProxy(MathNode_default, MathNode_default.ROUND);
var atan2 = nodeProxy(MathNode_default, MathNode_default.ATAN2);
var min = nodeProxy(MathNode_default, MathNode_default.MIN);
var max = nodeProxy(MathNode_default, MathNode_default.MAX);
var mod = nodeProxy(MathNode_default, MathNode_default.MOD);
var step = nodeProxy(MathNode_default, MathNode_default.STEP);
var reflect = nodeProxy(MathNode_default, MathNode_default.REFLECT);
var distance = nodeProxy(MathNode_default, MathNode_default.DISTANCE);
var dot = nodeProxy(MathNode_default, MathNode_default.DOT);
var cross = nodeProxy(MathNode_default, MathNode_default.CROSS);
var pow = nodeProxy(MathNode_default, MathNode_default.POW);
var pow2 = nodeProxy(MathNode_default, MathNode_default.POW, 2);
var pow3 = nodeProxy(MathNode_default, MathNode_default.POW, 3);
var pow4 = nodeProxy(MathNode_default, MathNode_default.POW, 4);
var transformDirection = nodeProxy(MathNode_default, MathNode_default.TRANSFORM_DIRECTION);
var mix = nodeProxy(MathNode_default, MathNode_default.MIX);
var clamp = nodeProxy(MathNode_default, MathNode_default.CLAMP);
var refract = nodeProxy(MathNode_default, MathNode_default.REFRACT);
var smoothstep = nodeProxy(MathNode_default, MathNode_default.SMOOTHSTEP);
var faceforward = nodeProxy(MathNode_default, MathNode_default.FACEFORWARD);
var frontFacing = nodeImmutable(FrontFacingNode_default);
var faceDirection = sub(mul(float(frontFacing), 2), 1);
var element = nodeProxy(ArrayElementNode_default);
var dotNV = saturate(dot(transformedNormalView, positionViewDirection));
var transformedNormalWorld = normalize(transformDirection(transformedNormalView, cameraViewMatrix));
export {
  EPSILON,
  INFINITY,
  ShaderNode,
  abs,
  acos,
  add,
  alphaTest,
  and,
  asin,
  assign,
  atan,
  atan2,
  attribute,
  bitAnd,
  bitOr,
  bitXor,
  bmat3,
  bmat4,
  bool,
  buffer,
  bvec2,
  bvec3,
  bvec4,
  bypass,
  call,
  cameraNormalMatrix,
  cameraPosition,
  cameraProjectionMatrix,
  cameraViewMatrix,
  cameraWorldMatrix,
  ceil,
  clamp,
  code,
  color,
  compute,
  cond,
  context,
  cos,
  cross,
  dFdx,
  dFdy,
  degrees,
  diffuseColor,
  distance,
  div,
  dot,
  dotNV,
  element,
  equal,
  exp,
  exp2,
  expression,
  faceDirection,
  faceforward,
  float,
  floor,
  fn,
  fract,
  frontFacing,
  func,
  greaterThan,
  greaterThanEqual,
  imat3,
  imat4,
  instanceIndex,
  int,
  inversesqrt,
  invert,
  ivec2,
  ivec3,
  ivec4,
  label,
  length,
  lessThan,
  lessThanEqual,
  log,
  log2,
  mat3,
  mat4,
  materialAlphaTest,
  materialColor,
  materialEmissive,
  materialMetalness,
  materialOpacity,
  materialReference,
  materialRotation,
  materialRoughness,
  max,
  metalness,
  min,
  mix,
  mod,
  modelNormalMatrix,
  modelPosition,
  modelViewMatrix,
  modelViewPosition,
  modelViewProjection,
  modelWorldMatrix,
  mul,
  negate,
  nodeArray,
  nodeImmutable,
  nodeObject,
  nodeObjects,
  nodeProxy,
  normalGeometry,
  normalLocal,
  normalView,
  normalWorld,
  normalize,
  or,
  pointUV,
  positionGeometry,
  positionLocal,
  positionView,
  positionViewDirection,
  positionWorld,
  pow,
  pow2,
  pow3,
  pow4,
  property,
  radians,
  reference,
  reflect,
  refract,
  remainder,
  roughness,
  round,
  sampler,
  saturate,
  shiftLeft,
  shiftRight,
  sign,
  sin,
  smoothstep,
  specularColor,
  sqrt,
  step,
  storage,
  sub,
  tan,
  temp,
  texture,
  transformDirection,
  transformedNormalView,
  transformedNormalWorld,
  uint,
  umat3,
  umat4,
  uniform,
  userData,
  uv,
  uvec2,
  uvec3,
  uvec4,
  varying,
  vec2,
  vec3,
  vec4,
  xor
};
//# sourceMappingURL=three_addons_nodes_shadernode_ShaderNodeBaseElements__js.js.map
