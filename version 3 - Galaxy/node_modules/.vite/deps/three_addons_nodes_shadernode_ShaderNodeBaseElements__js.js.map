{
  "version": 3,
  "sources": ["../../three/examples/jsm/nodes/core/constants.js", "../../three/examples/jsm/nodes/core/NodeUtils.js", "../../three/examples/jsm/nodes/core/Node.js", "../../three/examples/jsm/nodes/core/VaryingNode.js", "../../three/examples/jsm/nodes/core/AttributeNode.js", "../../three/examples/jsm/nodes/core/BypassNode.js", "../../three/examples/jsm/nodes/core/CodeNode.js", "../../three/examples/jsm/nodes/core/ContextNode.js", "../../three/examples/jsm/nodes/core/TempNode.js", "../../three/examples/jsm/nodes/core/ExpressionNode.js", "../../three/examples/jsm/nodes/core/FunctionCallNode.js", "../../three/examples/jsm/nodes/core/FunctionNode.js", "../../three/examples/jsm/nodes/core/InstanceIndexNode.js", "../../three/examples/jsm/nodes/core/PropertyNode.js", "../../three/examples/jsm/nodes/core/InputNode.js", "../../three/examples/jsm/nodes/core/UniformNode.js", "../../three/examples/jsm/nodes/math/OperatorNode.js", "../../three/examples/jsm/nodes/core/VarNode.js", "../../three/examples/jsm/nodes/accessors/BufferNode.js", "../../three/examples/jsm/nodes/accessors/Object3DNode.js", "../../three/examples/jsm/nodes/accessors/CameraNode.js", "../../three/examples/jsm/nodes/accessors/ReferenceNode.js", "../../three/examples/jsm/nodes/accessors/MaterialReferenceNode.js", "../../three/examples/jsm/nodes/accessors/UVNode.js", "../../three/examples/jsm/nodes/accessors/TextureNode.js", "../../three/examples/jsm/nodes/core/NodeBuilder.js", "../../three/examples/jsm/nodes/utils/SplitNode.js", "../../three/examples/jsm/nodes/accessors/MaterialNode.js", "../../three/examples/jsm/nodes/accessors/ModelNode.js", "../../three/examples/jsm/nodes/math/MathNode.js", "../../three/examples/jsm/nodes/accessors/PositionNode.js", "../../three/examples/jsm/nodes/accessors/ModelViewProjectionNode.js", "../../three/examples/jsm/nodes/accessors/NormalNode.js", "../../three/examples/jsm/nodes/accessors/PointUVNode.js", "../../three/examples/jsm/nodes/accessors/StorageBufferNode.js", "../../three/examples/jsm/nodes/accessors/UserDataNode.js", "../../three/examples/jsm/nodes/display/FrontFacingNode.js", "../../three/examples/jsm/nodes/gpgpu/ComputeNode.js", "../../three/examples/jsm/nodes/math/CondNode.js", "../../three/examples/jsm/nodes/utils/ArrayElementNode.js", "../../three/examples/jsm/nodes/utils/ConvertNode.js", "../../three/examples/jsm/nodes/utils/JoinNode.js", "../../three/examples/jsm/nodes/core/ConstNode.js", "../../three/examples/jsm/nodes/shadernode/ShaderNode.js", "../../three/examples/jsm/nodes/shadernode/ShaderNodeBaseElements.js"],
  "sourcesContent": ["export const NodeShaderStage = {\r\n\tVertex: 'vertex',\r\n\tFragment: 'fragment'\r\n};\r\n\r\nexport const NodeUpdateType = {\r\n\tNone: 'none',\r\n\tFrame: 'frame',\r\n\tObject: 'object'\r\n};\r\n\r\nexport const NodeType = {\r\n\tBoolean: 'bool',\r\n\tInteger: 'int',\r\n\tFloat: 'float',\r\n\tVector2: 'vec2',\r\n\tVector3: 'vec3',\r\n\tVector4: 'vec4',\r\n\tMatrix3: 'mat3',\r\n\tMatrix4: 'mat4'\r\n};\r\n", "import { Color, Matrix3, Matrix4, Vector2, Vector3, Vector4 } from 'three';\r\n\r\nexport const getCacheKey = ( object ) => {\r\n\r\n\tlet cacheKey = '{';\r\n\r\n\tif ( object.isNode === true ) {\r\n\r\n\t\tcacheKey += `uuid:\"${ object.uuid }\",`;\r\n\r\n\t}\r\n\r\n\tfor ( const property of getNodesKeys( object ) ) {\r\n\r\n\t\tcacheKey += `${ property }:${ object[ property ].getCacheKey() },`;\r\n\r\n\t}\r\n\r\n\tcacheKey += '}';\r\n\r\n\treturn cacheKey;\r\n\r\n};\r\n\r\nexport const getNodesKeys = ( object ) => {\r\n\r\n\tconst props = [];\r\n\r\n\tfor ( const name in object ) {\r\n\r\n\t\tconst value = object[ name ];\r\n\r\n\t\tif ( value && value.isNode === true ) {\r\n\r\n\t\t\tprops.push( name );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn props;\r\n\r\n};\r\n\r\nexport const getValueType = ( value ) => {\r\n\r\n\tif ( typeof value === 'number' ) {\r\n\r\n\t\treturn 'float';\r\n\r\n\t} else if ( typeof value === 'boolean' ) {\r\n\r\n\t\treturn 'bool';\r\n\r\n\t} else if ( value?.isVector2 === true ) {\r\n\r\n\t\treturn 'vec2';\r\n\r\n\t} else if ( value?.isVector3 === true ) {\r\n\r\n\t\treturn 'vec3';\r\n\r\n\t} else if ( value?.isVector4 === true ) {\r\n\r\n\t\treturn 'vec4';\r\n\r\n\t} else if ( value?.isMatrix3 === true ) {\r\n\r\n\t\treturn 'mat3';\r\n\r\n\t} else if ( value?.isMatrix4 === true ) {\r\n\r\n\t\treturn 'mat4';\r\n\r\n\t} else if ( value?.isColor === true ) {\r\n\r\n\t\treturn 'color';\r\n\r\n\t}\r\n\r\n\treturn null;\r\n\r\n};\r\n\r\nexport const getValueFromType = ( type, ...params ) => {\r\n\r\n\tconst last4 = type?.slice( - 4 );\r\n\r\n\tif ( type === 'color' ) {\r\n\r\n\t\treturn new Color( ...params );\r\n\r\n\t} else if ( last4 === 'vec2' ) {\r\n\r\n\t\treturn new Vector2( ...params );\r\n\r\n\t} else if ( last4 === 'vec3' ) {\r\n\r\n\t\treturn new Vector3( ...params );\r\n\r\n\t} else if ( last4 === 'vec4' ) {\r\n\r\n\t\treturn new Vector4( ...params );\r\n\r\n\t} else if ( last4 === 'mat3' ) {\r\n\r\n\t\treturn new Matrix3( ...params );\r\n\r\n\t} else if ( last4 === 'mat4' ) {\r\n\r\n\t\treturn new Matrix4( ...params );\r\n\r\n\t} else if ( type === 'bool' ) {\r\n\r\n\t\treturn false;\r\n\r\n\t} else if ( ( type === 'float' ) || ( type === 'int' ) || ( type === 'uint' ) ) {\r\n\r\n\t\treturn 0;\r\n\r\n\t}\r\n\r\n\treturn null;\r\n\r\n};\r\n", "import { NodeUpdateType } from './constants.js';\r\nimport { getNodesKeys, getCacheKey } from './NodeUtils.js';\r\nimport { MathUtils } from 'three';\r\n\r\nlet _nodeId = 0;\r\n\r\nclass Node {\r\n\r\n\tconstructor( nodeType = null ) {\r\n\r\n\t\tthis.isNode = true;\r\n\r\n\t\tthis.nodeType = nodeType;\r\n\r\n\t\tthis.updateType = NodeUpdateType.None;\r\n\r\n\t\tthis.uuid = MathUtils.generateUUID();\r\n\r\n\t\tObject.defineProperty( this, 'id', { value: _nodeId ++ } );\r\n\r\n\t}\r\n\r\n\tget type() {\r\n\r\n\t\treturn this.constructor.name;\r\n\r\n\t}\r\n\r\n\tgetChildren() {\r\n\r\n\t\tconst children = [];\r\n\r\n\t\tfor ( const property in this ) {\r\n\r\n\t\t\tconst object = this[ property ];\r\n\r\n\t\t\tif ( Array.isArray( object ) === true ) {\r\n\r\n\t\t\t\tfor ( const child of object ) {\r\n\r\n\t\t\t\t\tif ( child?.isNode === true ) {\r\n\r\n\t\t\t\t\t\tchildren.push( child );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object?.isNode === true ) {\r\n\r\n\t\t\t\tchildren.push( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn children;\r\n\r\n\t}\r\n\r\n\tgetCacheKey() {\r\n\r\n\t\treturn getCacheKey( this );\r\n\r\n\t}\r\n\r\n\tgetHash( /*builder*/ ) {\r\n\r\n\t\treturn this.uuid;\r\n\r\n\t}\r\n\r\n\tgetUpdateType( /*builder*/ ) {\r\n\r\n\t\treturn this.updateType;\r\n\r\n\t}\r\n\r\n\tgetNodeType( /*builder*/ ) {\r\n\r\n\t\treturn this.nodeType;\r\n\r\n\t}\r\n\r\n\tgetConstructHash( /*builder*/ ) {\r\n\r\n\t\treturn this.uuid;\r\n\r\n\t}\r\n\r\n\tgetReference( builder ) {\r\n\r\n\t\tconst hash = this.getHash( builder );\r\n\t\tconst nodeFromHash = builder.getNodeFromHash( hash );\r\n\r\n\t\treturn nodeFromHash || this;\r\n\r\n\t}\r\n\r\n\tconstruct( builder ) {\r\n\r\n\t\tconst nodeProperties = builder.getNodeProperties( this );\r\n\r\n\t\tfor ( const childNode of this.getChildren() ) {\r\n\r\n\t\t\tnodeProperties[ '_node' + childNode.id ] = childNode;\r\n\r\n\t\t}\r\n\r\n\t\t// return a outputNode if exists\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n\tanalyze( builder ) {\r\n\r\n\t\tconst nodeData = builder.getDataFromNode( this );\r\n\t\tnodeData.dependenciesCount = nodeData.dependenciesCount === undefined ? 1 : nodeData.dependenciesCount + 1;\r\n\r\n\t\tif ( nodeData.dependenciesCount === 1 ) {\r\n\r\n\t\t\t// node flow children\r\n\r\n\t\t\tconst nodeProperties = builder.getNodeProperties( this );\r\n\r\n\t\t\tfor ( const childNode of Object.values( nodeProperties ) ) {\r\n\r\n\t\t\t\tif ( childNode?.isNode === true ) {\r\n\r\n\t\t\t\t\tchildNode.build( builder );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgenerate( builder, output ) {\r\n\r\n\t\tconst { outputNode } = builder.getNodeProperties( this );\r\n\r\n\t\tif ( outputNode?.isNode === true ) {\r\n\r\n\t\t\treturn outputNode.build( builder, output );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdate( /*frame*/ ) {\r\n\r\n\t\tconsole.warn( 'Abstract function.' );\r\n\r\n\t}\r\n\r\n\tbuild( builder, output = null ) {\r\n\r\n\t\tconst refNode = this.getReference( builder );\r\n\r\n\t\tif ( this !== refNode ) {\r\n\r\n\t\t\treturn refNode.build( builder, output );\r\n\r\n\t\t}\r\n\r\n\t\tbuilder.addNode( this );\r\n\t\tbuilder.addStack( this );\r\n\r\n\t\t/* expected return:\r\n\t\t\t- \"construct\"\t-> Node\r\n\t\t\t- \"analyze\"\t\t-> null\r\n\t\t\t- \"generate\"\t-> String\r\n\t\t*/\r\n\t\tlet result = null;\r\n\r\n\t\tconst buildStage = builder.getBuildStage();\r\n\r\n\t\tif ( buildStage === 'construct' ) {\r\n\r\n\t\t\tconst properties = builder.getNodeProperties( this );\r\n\r\n\t\t\tif ( properties.initialized !== true || builder.context.tempRead === false ) {\r\n\r\n\t\t\t\tproperties.initialized = true;\r\n\t\t\t\tproperties.outputNode = this.construct( builder );\r\n\r\n\t\t\t\tfor ( const childNode of Object.values( properties ) ) {\r\n\r\n\t\t\t\t\tif ( childNode?.isNode === true ) {\r\n\r\n\t\t\t\t\t\tchildNode.build( builder );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( buildStage === 'analyze' ) {\r\n\r\n\t\t\tthis.analyze( builder );\r\n\r\n\t\t} else if ( buildStage === 'generate' ) {\r\n\r\n\t\t\tconst isGenerateOnce = this.generate.length === 1;\r\n\r\n\t\t\tif ( isGenerateOnce ) {\r\n\r\n\t\t\t\tconst type = this.getNodeType( builder );\r\n\t\t\t\tconst nodeData = builder.getDataFromNode( this );\r\n\r\n\t\t\t\tresult = nodeData.snippet;\r\n\r\n\t\t\t\tif ( result === undefined /*|| builder.context.tempRead === false*/ ) {\r\n\r\n\t\t\t\t\tresult = this.generate( builder ) || '';\r\n\r\n\t\t\t\t\tnodeData.snippet = result;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tresult = builder.format( result, type, output );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tresult = this.generate( builder, output ) || '';\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tbuilder.removeStack( this );\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tserialize( json ) {\r\n\r\n\t\tconst nodeKeys = getNodesKeys( this );\r\n\r\n\t\tif ( nodeKeys.length > 0 ) {\r\n\r\n\t\t\tconst inputNodes = {};\r\n\r\n\t\t\tfor ( const property of nodeKeys ) {\r\n\r\n\t\t\t\tinputNodes[ property ] = this[ property ].toJSON( json.meta ).uuid;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tjson.inputNodes = inputNodes;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tdeserialize( json ) {\r\n\r\n\t\tif ( json.inputNodes !== undefined ) {\r\n\r\n\t\t\tconst nodes = json.meta.nodes;\r\n\r\n\t\t\tfor ( const property in json.inputNodes ) {\r\n\r\n\t\t\t\tconst uuid = json.inputNodes[ property ];\r\n\r\n\t\t\t\tthis[ property ] = nodes[ uuid ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttoJSON( meta ) {\r\n\r\n\t\tconst { uuid, type } = this;\r\n\t\tconst isRoot = ( meta === undefined || typeof meta === 'string' );\r\n\r\n\t\tif ( isRoot ) {\r\n\r\n\t\t\tmeta = {\r\n\t\t\t\ttextures: {},\r\n\t\t\t\timages: {},\r\n\t\t\t\tnodes: {}\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\t// serialize\r\n\r\n\t\tlet data = meta.nodes[ uuid ];\r\n\r\n\t\tif ( data === undefined ) {\r\n\r\n\t\t\tdata = {\r\n\t\t\t\tuuid,\r\n\t\t\t\ttype,\r\n\t\t\t\tmeta,\r\n\t\t\t\tmetadata: {\r\n\t\t\t\t\tversion: 4.5,\r\n\t\t\t\t\ttype: 'Node',\r\n\t\t\t\t\tgenerator: 'Node.toJSON'\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tmeta.nodes[ data.uuid ] = data;\r\n\r\n\t\t\tthis.serialize( data );\r\n\r\n\t\t\tdelete data.meta;\r\n\r\n\t\t}\r\n\r\n\t\t// TODO: Copied from Object3D.toJSON\r\n\r\n\t\tfunction extractFromCache( cache ) {\r\n\r\n\t\t\tconst values = [];\r\n\r\n\t\t\tfor ( const key in cache ) {\r\n\r\n\t\t\t\tconst data = cache[ key ];\r\n\t\t\t\tdelete data.metadata;\r\n\t\t\t\tvalues.push( data );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn values;\r\n\r\n\t\t}\r\n\r\n\t\tif ( isRoot ) {\r\n\r\n\t\t\tconst textures = extractFromCache( meta.textures );\r\n\t\t\tconst images = extractFromCache( meta.images );\r\n\t\t\tconst nodes = extractFromCache( meta.nodes );\r\n\r\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\r\n\t\t\tif ( images.length > 0 ) data.images = images;\r\n\t\t\tif ( nodes.length > 0 ) data.nodes = nodes;\r\n\r\n\t\t}\r\n\r\n\t\treturn data;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default Node;\r\n", "import Node from './Node.js';\r\nimport { NodeShaderStage } from './constants.js';\r\n\r\nclass VaryingNode extends Node {\r\n\r\n\tconstructor( node, name = null ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.node = node;\r\n\t\tthis.name = name;\r\n\r\n\t}\r\n\r\n\tgetHash( builder ) {\r\n\r\n\t\treturn this.name || super.getHash( builder );\r\n\r\n\t}\r\n\r\n\tgetNodeType( builder ) {\r\n\r\n\t\t// VaryingNode is auto type\r\n\r\n\t\treturn this.node.getNodeType( builder );\r\n\r\n\t}\r\n\r\n\tgenerate( builder ) {\r\n\r\n\t\tconst type = this.getNodeType( builder );\r\n\t\tconst node = this.node;\r\n\t\tconst name = this.name;\r\n\r\n\t\tconst nodeVarying = builder.getVaryingFromNode( this, type );\r\n\r\n\t\tif ( name !== null ) {\r\n\r\n\t\t\tnodeVarying.name = name;\r\n\r\n\t\t}\r\n\r\n\t\tconst propertyName = builder.getPropertyName( nodeVarying, NodeShaderStage.Vertex );\r\n\r\n\t\t// force node run in vertex stage\r\n\t\tbuilder.flowNodeFromShaderStage( NodeShaderStage.Vertex, node, type, propertyName );\r\n\r\n\t\treturn builder.getPropertyName( nodeVarying );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default VaryingNode;\r\n", "import Node from './Node.js';\r\nimport VaryingNode from './VaryingNode.js';\r\n\r\nclass AttributeNode extends Node {\r\n\r\n\tconstructor( attributeName, nodeType = null ) {\r\n\r\n\t\tsuper( nodeType );\r\n\r\n\t\tthis._attributeName = attributeName;\r\n\r\n\t}\r\n\r\n\tgetHash( builder ) {\r\n\r\n\t\treturn this.getAttributeName( builder );\r\n\r\n\t}\r\n\r\n\tgetNodeType( builder ) {\r\n\r\n\t\tlet nodeType = super.getNodeType( builder );\r\n\r\n\t\tif ( nodeType === null ) {\r\n\r\n\t\t\tconst attributeName = this.getAttributeName( builder );\r\n\t\t\tconst attribute = builder.geometry.getAttribute( attributeName );\r\n\r\n\t\t\tnodeType = builder.getTypeFromLength( attribute.itemSize );\r\n\r\n\t\t}\r\n\r\n\t\treturn nodeType;\r\n\r\n\t}\r\n\r\n\tsetAttributeName( attributeName ) {\r\n\r\n\t\tthis._attributeName = attributeName;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tgetAttributeName( /*builder*/ ) {\r\n\r\n\t\treturn this._attributeName;\r\n\r\n\t}\r\n\r\n\tgenerate( builder ) {\r\n\r\n\t\tconst attribute = builder.getAttribute( this.getAttributeName( builder ), this.getNodeType( builder ) );\r\n\r\n\t\tif ( builder.isShaderStage( 'vertex' ) ) {\r\n\r\n\t\t\treturn attribute.name;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst nodeVarying = new VaryingNode( this );\r\n\r\n\t\t\treturn nodeVarying.build( builder, attribute.type );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default AttributeNode;\r\n", "import Node from './Node.js';\r\n\r\nclass BypassNode extends Node {\r\n\r\n\tconstructor( returnNode, callNode ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.isBypassNode = true;\r\n\r\n\t\tthis.outputNode = returnNode;\r\n\t\tthis.callNode = callNode;\r\n\r\n\t}\r\n\r\n\tgetNodeType( builder ) {\r\n\r\n\t\treturn this.outputNode.getNodeType( builder );\r\n\r\n\t}\r\n\r\n\tgenerate( builder, output ) {\r\n\r\n\t\tconst snippet = this.callNode.build( builder, 'void' );\r\n\r\n\t\tif ( snippet !== '' ) {\r\n\r\n\t\t\tbuilder.addFlowCode( snippet );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.outputNode.build( builder, output );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default BypassNode;\r\n", "import Node from './Node.js';\r\n\r\nclass CodeNode extends Node {\r\n\r\n\tconstructor( code = '', includes = [] ) {\r\n\r\n\t\tsuper( 'code' );\r\n\r\n\t\tthis.isCodeNode = true;\r\n\r\n\t\tthis.code = code;\r\n\r\n\t\tthis._includes = includes;\r\n\r\n\t}\r\n\r\n\tsetIncludes( includes ) {\r\n\r\n\t\tthis._includes = includes;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tgetIncludes( /*builder*/ ) {\r\n\r\n\t\treturn this._includes;\r\n\r\n\t}\r\n\r\n\tgenerate( builder ) {\r\n\r\n\t\tconst includes = this.getIncludes( builder );\r\n\r\n\t\tfor ( const include of includes ) {\r\n\r\n\t\t\tinclude.build( builder );\r\n\r\n\t\t}\r\n\r\n\t\tconst nodeCode = builder.getCodeFromNode( this, this.getNodeType( builder ) );\r\n\t\tnodeCode.code = this.code;\r\n\r\n\t\treturn nodeCode.code;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default CodeNode;\r\n", "import Node from './Node.js';\r\n\r\nclass ContextNode extends Node {\r\n\r\n\tconstructor( node, context = {} ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.isContextNode = true;\r\n\r\n\t\tthis.node = node;\r\n\t\tthis.context = context;\r\n\r\n\t}\r\n\r\n\tgetNodeType( builder ) {\r\n\r\n\t\treturn this.node.getNodeType( builder );\r\n\r\n\t}\r\n\r\n\tconstruct( builder ) {\r\n\r\n\t\tconst previousContext = builder.getContext();\r\n\r\n\t\tbuilder.setContext( { ...builder.context, ...this.context } );\r\n\r\n\t\tconst node = this.node.build( builder );\r\n\r\n\t\tbuilder.setContext( previousContext );\r\n\r\n\t\treturn node;\r\n\r\n\t}\r\n\r\n\tgenerate( builder, output ) {\r\n\r\n\t\tconst previousContext = builder.getContext();\r\n\r\n\t\tbuilder.setContext( { ...builder.context, ...this.context } );\r\n\r\n\t\tconst snippet = this.node.build( builder, output );\r\n\r\n\t\tbuilder.setContext( previousContext );\r\n\r\n\t\treturn snippet;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default ContextNode;\r\n", "import Node from './Node.js';\r\n\r\nclass TempNode extends Node {\r\n\r\n\tconstructor( type ) {\r\n\r\n\t\tsuper( type );\r\n\r\n\t\tthis.isTempNode = true;\r\n\r\n\t}\r\n\r\n\tbuild( builder, output ) {\r\n\r\n\t\tconst buildStage = builder.getBuildStage();\r\n\r\n\t\tif ( buildStage === 'generate' ) {\r\n\r\n\t\t\tconst type = builder.getVectorType( this.getNodeType( builder, output ) );\r\n\t\t\tconst nodeData = builder.getDataFromNode( this );\r\n\r\n\t\t\tif ( builder.context.tempRead !== false && nodeData.propertyName !== undefined ) {\r\n\r\n\t\t\t\treturn builder.format( nodeData.propertyName, type, output );\r\n\r\n\t\t\t} else if ( builder.context.tempWrite !== false && type !== 'void ' && output !== 'void' && nodeData.dependenciesCount > 1 ) {\r\n\r\n\t\t\t\tconst snippet = super.build( builder, type );\r\n\r\n\t\t\t\tconst nodeVar = builder.getVarFromNode( this, type );\r\n\t\t\t\tconst propertyName = builder.getPropertyName( nodeVar );\r\n\r\n\t\t\t\tbuilder.addFlowCode( `${propertyName} = ${snippet}` );\r\n\r\n\t\t\t\tnodeData.snippet = snippet;\r\n\t\t\t\tnodeData.propertyName = propertyName;\r\n\r\n\t\t\t\treturn builder.format( nodeData.propertyName, type, output );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn super.build( builder, output );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default TempNode;\r\n", "import TempNode from './TempNode.js';\r\n\r\nclass ExpressionNode extends TempNode {\r\n\r\n\tconstructor( snipped = '', nodeType = 'void' ) {\r\n\r\n\t\tsuper( nodeType );\r\n\r\n\t\tthis.snipped = snipped;\r\n\r\n\t}\r\n\r\n\tgenerate( builder ) {\r\n\r\n\t\tconst type = this.getNodeType( builder );\r\n\t\tconst snipped = this.snipped;\r\n\r\n\t\tif ( type === 'void' ) {\r\n\r\n\t\t\tbuilder.addFlowCode( snipped );\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn `( ${ snipped } )`;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default ExpressionNode;\r\n", "import TempNode from './TempNode.js';\r\n\r\nclass FunctionCallNode extends TempNode {\r\n\r\n\tconstructor( functionNode = null, parameters = {} ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.functionNode = functionNode;\r\n\t\tthis.parameters = parameters;\r\n\r\n\t}\r\n\r\n\tsetParameters( parameters ) {\r\n\r\n\t\tthis.parameters = parameters;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tgetParameters() {\r\n\r\n\t\treturn this.parameters;\r\n\r\n\t}\r\n\r\n\tgetNodeType( builder ) {\r\n\r\n\t\treturn this.functionNode.getNodeType( builder );\r\n\r\n\t}\r\n\r\n\tgenerate( builder ) {\r\n\r\n\t\tconst params = [];\r\n\r\n\t\tconst functionNode = this.functionNode;\r\n\r\n\t\tconst inputs = functionNode.getInputs( builder );\r\n\t\tconst parameters = this.parameters;\r\n\r\n\t\tif ( Array.isArray( parameters ) ) {\r\n\r\n\t\t\tfor ( let i = 0; i < parameters.length; i ++ ) {\r\n\r\n\t\t\t\tconst inputNode = inputs[ i ];\r\n\t\t\t\tconst node = parameters[ i ];\r\n\r\n\t\t\t\tparams.push( node.build( builder, inputNode.type ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( const inputNode of inputs ) {\r\n\r\n\t\t\t\tconst node = parameters[ inputNode.name ];\r\n\r\n\t\t\t\tif ( node !== undefined ) {\r\n\r\n\t\t\t\t\tparams.push( node.build( builder, inputNode.type ) );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthrow new Error( `FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.` );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst functionName = functionNode.build( builder, 'property' );\r\n\r\n\t\treturn `${functionName}( ${params.join( ', ' )} )`;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default FunctionCallNode;\r\n", "import CodeNode from './CodeNode.js';\r\nimport FunctionCallNode from './FunctionCallNode.js';\r\n\r\nclass FunctionNode extends CodeNode {\r\n\r\n\tconstructor( code = '', includes = [] ) {\r\n\r\n\t\tsuper( code, includes );\r\n\r\n\t\tthis.keywords = {};\r\n\r\n\t}\r\n\r\n\tgetNodeType( builder ) {\r\n\r\n\t\treturn this.getNodeFunction( builder ).type;\r\n\r\n\t}\r\n\r\n\tgetInputs( builder ) {\r\n\r\n\t\treturn this.getNodeFunction( builder ).inputs;\r\n\r\n\t}\r\n\r\n\tgetNodeFunction( builder ) {\r\n\r\n\t\tconst nodeData = builder.getDataFromNode( this );\r\n\r\n\t\tlet nodeFunction = nodeData.nodeFunction;\r\n\r\n\t\tif ( nodeFunction === undefined ) {\r\n\r\n\t\t\tnodeFunction = builder.parser.parseFunction( this.code );\r\n\r\n\t\t\tnodeData.nodeFunction = nodeFunction;\r\n\r\n\t\t}\r\n\r\n\t\treturn nodeFunction;\r\n\r\n\t}\r\n\r\n\tcall( parameters = {} ) {\r\n\r\n\t\treturn new FunctionCallNode( this, parameters );\r\n\r\n\t}\r\n\r\n\tgenerate( builder, output ) {\r\n\r\n\t\tsuper.generate( builder );\r\n\r\n\t\tconst nodeFunction = this.getNodeFunction( builder );\r\n\r\n\t\tconst name = nodeFunction.name;\r\n\t\tconst type = nodeFunction.type;\r\n\r\n\t\tconst nodeCode = builder.getCodeFromNode( this, type );\r\n\r\n\t\tif ( name !== '' ) {\r\n\r\n\t\t\t// use a custom property name\r\n\r\n\t\t\tnodeCode.name = name;\r\n\r\n\t\t}\r\n\r\n\t\tconst propertyName = builder.getPropertyName( nodeCode );\r\n\r\n\t\tlet code = this.getNodeFunction( builder ).getCode( propertyName );\r\n\r\n\t\tconst keywords = this.keywords;\r\n\t\tconst keywordsProperties = Object.keys( keywords );\r\n\r\n\t\tif ( keywordsProperties.length > 0 ) {\r\n\r\n\t\t\tfor ( const property of keywordsProperties ) {\r\n\r\n\t\t\t\tconst propertyRegExp = new RegExp( `\\\\b${property}\\\\b`, 'g' );\r\n\t\t\t\tconst nodeProperty = keywords[ property ].build( builder, 'property' );\r\n\r\n\t\t\t\tcode = code.replace( propertyRegExp, nodeProperty );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tnodeCode.code = code;\r\n\r\n\t\tif ( output === 'property' ) {\r\n\r\n\t\t\treturn propertyName;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn builder.format( `${ propertyName }()`, type, output );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default FunctionNode;\r\n", "import Node from './Node.js';\r\n\r\nclass InstanceIndexNode extends Node {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper( 'uint' );\r\n\r\n\t\tthis.isInstanceIndexNode = true;\r\n\r\n\t}\r\n\r\n\tgenerate( builder ) {\r\n\r\n\t\treturn builder.getInstanceIndex();\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default InstanceIndexNode;\r\n", "import Node from './Node.js';\r\n\r\nclass PropertyNode extends Node {\r\n\r\n\tconstructor( name = null, nodeType = 'vec4' ) {\r\n\r\n\t\tsuper( nodeType );\r\n\r\n\t\tthis.name = name;\r\n\r\n\t}\r\n\r\n\tgetHash( builder ) {\r\n\r\n\t\treturn this.name || super.getHash( builder );\r\n\r\n\t}\r\n\r\n\tgenerate( builder ) {\r\n\r\n\t\tconst nodeVary = builder.getVarFromNode( this, this.getNodeType( builder ) );\r\n\t\tconst name = this.name;\r\n\r\n\t\tif ( name !== null ) {\r\n\r\n\t\t\tnodeVary.name = name;\r\n\r\n\t\t}\r\n\r\n\t\treturn builder.getPropertyName( nodeVary );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default PropertyNode;\r\n", "import Node from './Node.js';\r\nimport { getValueType, getValueFromType } from './NodeUtils.js';\r\n\r\nclass InputNode extends Node {\r\n\r\n\tconstructor( value, nodeType = null ) {\r\n\r\n\t\tsuper( nodeType );\r\n\r\n\t\tthis.isInputNode = true;\r\n\r\n\t\tthis.value = value;\r\n\r\n\t}\r\n\r\n\tgetNodeType( /*builder*/ ) {\r\n\r\n\t\tif ( this.nodeType === null ) {\r\n\r\n\t\t\treturn getValueType( this.value );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.nodeType;\r\n\r\n\t}\r\n\r\n\tgetInputType( builder ) {\r\n\r\n\t\treturn this.getNodeType( builder );\r\n\r\n\t}\r\n\r\n\tserialize( data ) {\r\n\r\n\t\tsuper.serialize( data );\r\n\r\n\t\tdata.value = this.value?.toArray?.() || this.value;\r\n\t\tdata.valueType = getValueType( this.value );\r\n\t\tdata.nodeType = this.nodeType;\r\n\r\n\t}\r\n\r\n\tdeserialize( data ) {\r\n\r\n\t\tsuper.deserialize( data );\r\n\r\n\t\tthis.nodeType = data.nodeType;\r\n\t\tthis.value = getValueFromType( data.valueType );\r\n\t\tthis.value = this.value?.fromArray?.( data.value ) || data.value;\r\n\r\n\t}\r\n\r\n\tgenerate( /*builder, output*/ ) {\r\n\r\n\t\tconsole.warn( 'Abstract function.' );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default InputNode;\r\n", "import InputNode from './InputNode.js';\r\n\r\nclass UniformNode extends InputNode {\r\n\r\n\tconstructor( value, nodeType = null ) {\r\n\r\n\t\tsuper( value, nodeType );\r\n\r\n\t\tthis.isUniformNode = true;\r\n\r\n\t}\r\n\r\n\tgetUniformHash( builder ) {\r\n\r\n\t\treturn this.getHash( builder );\r\n\r\n\t}\r\n\r\n\tgenerate( builder, output ) {\r\n\r\n\t\tconst type = this.getNodeType( builder );\r\n\r\n\t\tconst hash = this.getUniformHash( builder );\r\n\r\n\t\tlet sharedNode = builder.getNodeFromHash( hash );\r\n\r\n\t\tif ( sharedNode === undefined ) {\r\n\r\n\t\t\tbuilder.setHashNode( this, hash );\r\n\r\n\t\t\tsharedNode = this;\r\n\r\n\t\t}\r\n\r\n\t\tconst sharedNodeType = sharedNode.getInputType( builder );\r\n\r\n\t\tconst nodeUniform = builder.getUniformFromNode( sharedNode, builder.shaderStage, sharedNodeType );\r\n\t\tconst propertyName = builder.getPropertyName( nodeUniform );\r\n\r\n\t\treturn builder.format( propertyName, type, output );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default UniformNode;\r\n", "import TempNode from '../core/TempNode.js';\r\n\r\nclass OperatorNode extends TempNode {\r\n\r\n\tconstructor( op, aNode, bNode, ...params ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.op = op;\r\n\r\n\t\tif ( params.length > 0 ) {\r\n\r\n\t\t\tlet finalBNode = bNode;\r\n\r\n\t\t\tfor ( let i = 0; i < params.length; i ++ ) {\r\n\r\n\t\t\t\tfinalBNode = new OperatorNode( op, finalBNode, params[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbNode = finalBNode;\r\n\r\n\t\t}\r\n\r\n\t\tthis.aNode = aNode;\r\n\t\tthis.bNode = bNode;\r\n\r\n\t}\r\n\r\n\tgetNodeType( builder, output ) {\r\n\r\n\t\tconst op = this.op;\r\n\r\n\t\tconst aNode = this.aNode;\r\n\t\tconst bNode = this.bNode;\r\n\r\n\t\tconst typeA = aNode.getNodeType( builder );\r\n\t\tconst typeB = bNode.getNodeType( builder );\r\n\r\n\t\tif ( typeA === 'void' || typeB === 'void' ) {\r\n\r\n\t\t\treturn 'void';\r\n\r\n\t\t} else if ( op === '=' || op === '%' ) {\r\n\r\n\t\t\treturn typeA;\r\n\r\n\t\t} else if ( op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<' ) {\r\n\r\n\t\t\treturn 'int';\r\n\r\n\t\t} else if ( op === '==' || op === '&&' || op === '||' || op === '^^' ) {\r\n\r\n\t\t\treturn 'bool';\r\n\r\n\t\t} else if ( op === '<' || op === '>' || op === '<=' || op === '>=' ) {\r\n\r\n\t\t\tconst typeLength = builder.getTypeLength( output );\r\n\r\n\t\t\treturn typeLength > 1 ? `bvec${ typeLength }` : 'bool';\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( typeA === 'float' && builder.isMatrix( typeB ) ) {\r\n\r\n\t\t\t\treturn typeB;\r\n\r\n\t\t\t} else if ( builder.isMatrix( typeA ) && builder.isVector( typeB ) ) {\r\n\r\n\t\t\t\t// matrix x vector\r\n\r\n\t\t\t\treturn builder.getVectorFromMatrix( typeA );\r\n\r\n\t\t\t} else if ( builder.isVector( typeA ) && builder.isMatrix( typeB ) ) {\r\n\r\n\t\t\t\t// vector x matrix\r\n\r\n\t\t\t\treturn builder.getVectorFromMatrix( typeB );\r\n\r\n\t\t\t} else if ( builder.getTypeLength( typeB ) > builder.getTypeLength( typeA ) ) {\r\n\r\n\t\t\t\t// anytype x anytype: use the greater length vector\r\n\r\n\t\t\t\treturn typeB;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn typeA;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgenerate( builder, output ) {\r\n\r\n\t\tconst op = this.op;\r\n\r\n\t\tconst aNode = this.aNode;\r\n\t\tconst bNode = this.bNode;\r\n\r\n\t\tconst type = this.getNodeType( builder, output );\r\n\r\n\t\tlet typeA = null;\r\n\t\tlet typeB = null;\r\n\r\n\t\tif ( type !== 'void' ) {\r\n\r\n\t\t\ttypeA = aNode.getNodeType( builder );\r\n\t\t\ttypeB = bNode.getNodeType( builder );\r\n\r\n\t\t\tif ( op === '=' ) {\r\n\r\n\t\t\t\ttypeB = typeA;\r\n\r\n\t\t\t} else if ( op === '<' || op === '>' || op === '<=' || op === '>=' ) {\r\n\r\n\t\t\t\tif ( builder.isVector( typeA ) ) {\r\n\r\n\t\t\t\t\ttypeB = typeA;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttypeA = typeB = 'float';\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( builder.isMatrix( typeA ) && builder.isVector( typeB ) ) {\r\n\r\n\t\t\t\t// matrix x vector\r\n\r\n\t\t\t\ttypeB = builder.getVectorFromMatrix( typeA );\r\n\r\n\t\t\t} else if ( builder.isVector( typeA ) && builder.isMatrix( typeB ) ) {\r\n\r\n\t\t\t\t// vector x matrix\r\n\r\n\t\t\t\ttypeA = builder.getVectorFromMatrix( typeB );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// anytype x anytype\r\n\r\n\t\t\t\ttypeA = typeB = type;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttypeA = typeB = type;\r\n\r\n\t\t}\r\n\r\n\t\tconst a = aNode.build( builder, typeA );\r\n\t\tconst b = bNode.build( builder, typeB );\r\n\r\n\t\tconst outputLength = builder.getTypeLength( output );\r\n\r\n\t\tif ( output !== 'void' ) {\r\n\r\n\t\t\tif ( op === '=' ) {\r\n\r\n\t\t\t\tbuilder.addFlowCode( `${a} ${this.op} ${b}` );\r\n\r\n\t\t\t\treturn a;\r\n\r\n\t\t\t} else if ( op === '>' && outputLength > 1 ) {\r\n\r\n\t\t\t\treturn builder.format( `${ builder.getMethod( 'greaterThan' ) }( ${a}, ${b} )`, type, output );\r\n\r\n\t\t\t} else if ( op === '<=' && outputLength > 1 ) {\r\n\r\n\t\t\t\treturn builder.format( `${ builder.getMethod( 'lessThanEqual' ) }( ${a}, ${b} )`, type, output );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn builder.format( `( ${a} ${this.op} ${b} )`, type, output );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( typeA !== 'void' ) {\r\n\r\n\t\t\treturn builder.format( `${a} ${this.op} ${b}`, type, output );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tserialize( data ) {\r\n\r\n\t\tsuper.serialize( data );\r\n\r\n\t\tdata.op = this.op;\r\n\r\n\t}\r\n\r\n\tdeserialize( data ) {\r\n\r\n\t\tsuper.deserialize( data );\r\n\r\n\t\tthis.op = data.op;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default OperatorNode;\r\n", "import Node from './Node.js';\r\nimport OperatorNode from '../math/OperatorNode.js';\r\n\r\nclass VarNode extends Node {\r\n\r\n\tconstructor( node, name = null ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.node = node;\r\n\t\tthis.name = name;\r\n\r\n\t}\r\n\r\n\top( op, ...params ) {\r\n\r\n\t\tthis.node = new OperatorNode( op, this.node, ...params );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tassign( ...params ) {\r\n\r\n\t\treturn this.op( '=', ...params );\r\n\r\n\t}\r\n\r\n\tadd( ...params ) {\r\n\r\n\t\treturn this.op( '+', ...params );\r\n\r\n\t}\r\n\r\n\tsub( ...params ) {\r\n\r\n\t\treturn this.op( '-', ...params );\r\n\r\n\t}\r\n\r\n\tmul( ...params ) {\r\n\r\n\t\treturn this.op( '*', ...params );\r\n\r\n\t}\r\n\r\n\tdiv( ...params ) {\r\n\r\n\t\treturn this.op( '/', ...params );\r\n\r\n\t}\r\n\r\n\tgetHash( builder ) {\r\n\r\n\t\treturn this.name || super.getHash( builder );\r\n\r\n\t}\r\n\r\n\tgetNodeType( builder ) {\r\n\r\n\t\treturn this.node.getNodeType( builder );\r\n\r\n\t}\r\n\r\n\tgenerate( builder ) {\r\n\r\n\t\tconst node = this.node;\r\n\t\tconst name = this.name;\r\n\r\n\t\tif ( name === null && node.isTempNode === true ) {\r\n\r\n\t\t\treturn node.build( builder );\r\n\r\n\t\t}\r\n\r\n\t\tconst type = builder.getVectorType( this.getNodeType( builder ) );\r\n\r\n\t\tconst snippet = node.build( builder, type );\r\n\t\tconst nodeVar = builder.getVarFromNode( this, type );\r\n\r\n\t\tif ( name !== null ) {\r\n\r\n\t\t\tnodeVar.name = name;\r\n\r\n\t\t}\r\n\r\n\t\tconst propertyName = builder.getPropertyName( nodeVar );\r\n\r\n\t\tbuilder.addFlowCode( `${propertyName} = ${snippet}` );\r\n\r\n\t\treturn propertyName;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default VarNode;\r\n", "import UniformNode from '../core/UniformNode.js';\r\n\r\nclass BufferNode extends UniformNode {\r\n\r\n\tconstructor( value, bufferType, bufferCount = 0 ) {\r\n\r\n\t\tsuper( value, bufferType );\r\n\r\n\t\tthis.isBufferNode = true;\r\n\r\n\t\tthis.bufferType = bufferType;\r\n\t\tthis.bufferCount = bufferCount;\r\n\r\n\t}\r\n\r\n\tgetInputType( /*builder*/ ) {\r\n\r\n\t\treturn 'buffer';\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default BufferNode;\r\n", "import { Vector3 } from 'three';\r\nimport Node from '../core/Node.js';\r\nimport UniformNode from '../core/UniformNode.js';\r\nimport { NodeUpdateType } from '../core/constants.js';\r\n\r\nclass Object3DNode extends Node {\r\n\r\n\tstatic VIEW_MATRIX = 'viewMatrix';\r\n\tstatic NORMAL_MATRIX = 'normalMatrix';\r\n\tstatic WORLD_MATRIX = 'worldMatrix';\r\n\tstatic POSITION = 'position';\r\n\tstatic VIEW_POSITION = 'viewPosition';\r\n\r\n\tconstructor( scope = Object3DNode.VIEW_MATRIX, object3d = null ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.scope = scope;\r\n\t\tthis.object3d = object3d;\r\n\r\n\t\tthis.updateType = NodeUpdateType.Object;\r\n\r\n\t\tthis._uniformNode = new UniformNode( null );\r\n\r\n\t}\r\n\r\n\tgetNodeType() {\r\n\r\n\t\tconst scope = this.scope;\r\n\r\n\t\tif ( scope === Object3DNode.WORLD_MATRIX || scope === Object3DNode.VIEW_MATRIX ) {\r\n\r\n\t\t\treturn 'mat4';\r\n\r\n\t\t} else if ( scope === Object3DNode.NORMAL_MATRIX ) {\r\n\r\n\t\t\treturn 'mat3';\r\n\r\n\t\t} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION ) {\r\n\r\n\t\t\treturn 'vec3';\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdate( frame ) {\r\n\r\n\t\tconst object = this.object3d;\r\n\t\tconst uniformNode = this._uniformNode;\r\n\t\tconst scope = this.scope;\r\n\r\n\t\tif ( scope === Object3DNode.VIEW_MATRIX ) {\r\n\r\n\t\t\tuniformNode.value = object.modelViewMatrix;\r\n\r\n\t\t} else if ( scope === Object3DNode.NORMAL_MATRIX ) {\r\n\r\n\t\t\tuniformNode.value = object.normalMatrix;\r\n\r\n\t\t} else if ( scope === Object3DNode.WORLD_MATRIX ) {\r\n\r\n\t\t\tuniformNode.value = object.matrixWorld;\r\n\r\n\t\t} else if ( scope === Object3DNode.POSITION ) {\r\n\r\n\t\t\tuniformNode.value.setFromMatrixPosition( object.matrixWorld );\r\n\r\n\t\t} else if ( scope === Object3DNode.VIEW_POSITION ) {\r\n\r\n\t\t\tconst camera = frame.camera;\r\n\r\n\t\t\tuniformNode.value = uniformNode.value || new Vector3();\r\n\t\t\tuniformNode.value.setFromMatrixPosition( object.matrixWorld );\r\n\r\n\t\t\tuniformNode.value.applyMatrix4( camera.matrixWorldInverse );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgenerate( builder ) {\r\n\r\n\t\tconst scope = this.scope;\r\n\r\n\t\tif ( scope === Object3DNode.WORLD_MATRIX || scope === Object3DNode.VIEW_MATRIX ) {\r\n\r\n\t\t\tthis._uniformNode.nodeType = 'mat4';\r\n\r\n\t\t} else if ( scope === Object3DNode.NORMAL_MATRIX ) {\r\n\r\n\t\t\tthis._uniformNode.nodeType = 'mat3';\r\n\r\n\t\t} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION ) {\r\n\r\n\t\t\tthis._uniformNode.nodeType = 'vec3';\r\n\r\n\t\t}\r\n\r\n\t\treturn this._uniformNode.build( builder );\r\n\r\n\t}\r\n\r\n\tserialize( data ) {\r\n\r\n\t\tsuper.serialize( data );\r\n\r\n\t\tdata.scope = this.scope;\r\n\r\n\t}\r\n\r\n\tdeserialize( data ) {\r\n\r\n\t\tsuper.deserialize( data );\r\n\r\n\t\tthis.scope = data.scope;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default Object3DNode;\r\n", "import Object3DNode from './Object3DNode.js';\r\n\r\nclass CameraNode extends Object3DNode {\r\n\r\n\tstatic PROJECTION_MATRIX = 'projectionMatrix';\r\n\r\n\tconstructor( scope = CameraNode.POSITION ) {\r\n\r\n\t\tsuper( scope );\r\n\r\n\t}\r\n\r\n\tgetNodeType( builder ) {\r\n\r\n\t\tconst scope = this.scope;\r\n\r\n\t\tif ( scope === CameraNode.PROJECTION_MATRIX ) {\r\n\r\n\t\t\treturn 'mat4';\r\n\r\n\t\t}\r\n\r\n\t\treturn super.getNodeType( builder );\r\n\r\n\t}\r\n\r\n\tupdate( frame ) {\r\n\r\n\t\tconst camera = frame.camera;\r\n\t\tconst uniformNode = this._uniformNode;\r\n\t\tconst scope = this.scope;\r\n\r\n\t\tif ( scope === CameraNode.PROJECTION_MATRIX ) {\r\n\r\n\t\t\tuniformNode.value = camera.projectionMatrix;\r\n\r\n\t\t} else if ( scope === CameraNode.VIEW_MATRIX ) {\r\n\r\n\t\t\tuniformNode.value = camera.matrixWorldInverse;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.object3d = camera;\r\n\r\n\t\t\tsuper.update( frame );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgenerate( builder ) {\r\n\r\n\t\tconst scope = this.scope;\r\n\r\n\t\tif ( scope === CameraNode.PROJECTION_MATRIX ) {\r\n\r\n\t\t\tthis._uniformNode.nodeType = 'mat4';\r\n\r\n\t\t}\r\n\r\n\t\treturn super.generate( builder );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default CameraNode;\r\n", "import Node from '../core/Node.js';\r\nimport UniformNode from '../core/UniformNode.js';\r\nimport { NodeUpdateType } from '../core/constants.js';\r\n\r\nclass ReferenceNode extends Node {\r\n\r\n\tconstructor( property, uniformType, object = null ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.property = property;\r\n\r\n\t\tthis.uniformType = uniformType;\r\n\r\n\t\tthis.object = object;\r\n\r\n\t\tthis.node = null;\r\n\r\n\t\tthis.updateType = NodeUpdateType.Object;\r\n\r\n\t\tthis.setNodeType( uniformType );\r\n\r\n\t}\r\n\r\n\tsetNodeType( uniformType ) {\r\n\r\n\t\tthis.node = new UniformNode( null, uniformType );\r\n\t\tthis.nodeType = uniformType;\r\n\r\n\t\tif ( uniformType === 'color' ) {\r\n\r\n\t\t\tthis.nodeType = 'vec3';\r\n\r\n\t\t} else if ( uniformType === 'texture' ) {\r\n\r\n\t\t\tthis.nodeType = 'vec4';\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgetNodeType() {\r\n\r\n\t\treturn this.uniformType;\r\n\r\n\t}\r\n\r\n\tupdate( frame ) {\r\n\r\n\t\tconst object = this.object !== null ? this.object : frame.object;\r\n\t\tconst value = object[ this.property ];\r\n\r\n\t\tthis.node.value = value;\r\n\r\n\t}\r\n\r\n\tgenerate( builder ) {\r\n\r\n\t\treturn this.node.build( builder, this.getNodeType( builder ) );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default ReferenceNode;\r\n", "import ReferenceNode from './ReferenceNode.js';\r\n\r\nclass MaterialReferenceNode extends ReferenceNode {\r\n\r\n\tconstructor( property, inputType, material = null ) {\r\n\r\n\t\tsuper( property, inputType, material );\r\n\r\n\t\tthis.material = material;\r\n\r\n\t}\r\n\r\n\tupdate( frame ) {\r\n\r\n\t\tthis.object = this.material !== null ? this.material : frame.material;\r\n\r\n\t\tsuper.update( frame );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default MaterialReferenceNode;\r\n", "import AttributeNode from '../core/AttributeNode.js';\r\n\r\nclass UVNode extends AttributeNode {\r\n\r\n\tconstructor( index = 0 ) {\r\n\r\n\t\tsuper( null, 'vec2' );\r\n\r\n\t\tthis.isUVNode = true;\r\n\r\n\t\tthis.index = index;\r\n\r\n\t}\r\n\r\n\tgetAttributeName( /*builder*/ ) {\r\n\r\n\t\tconst index = this.index;\r\n\r\n\t\treturn 'uv' + ( index > 0 ? index + 1 : '' );\r\n\r\n\t}\r\n\r\n\tserialize( data ) {\r\n\r\n\t\tsuper.serialize( data );\r\n\r\n\t\tdata.index = this.index;\r\n\r\n\t}\r\n\r\n\tdeserialize( data ) {\r\n\r\n\t\tsuper.deserialize( data );\r\n\r\n\t\tthis.index = data.index;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default UVNode;\r\n", "import UniformNode from '../core/UniformNode.js';\r\nimport UVNode from './UVNode.js';\r\n\r\nclass TextureNode extends UniformNode {\r\n\r\n\tconstructor( value, uvNode = new UVNode(), levelNode = null ) {\r\n\r\n\t\tsuper( value, 'vec4' );\r\n\r\n\t\tthis.isTextureNode = true;\r\n\r\n\t\tthis.uvNode = uvNode;\r\n\t\tthis.levelNode = levelNode;\r\n\r\n\t}\r\n\r\n\tgetUniformHash( /*builder*/ ) {\r\n\r\n\t\treturn this.value.uuid;\r\n\r\n\t}\r\n\r\n\tgetInputType( /*builder*/ ) {\r\n\r\n\t\treturn 'texture';\r\n\r\n\t}\r\n\r\n\tgenerate( builder, output ) {\r\n\r\n\t\tconst texture = this.value;\r\n\r\n\t\tif ( ! texture || texture.isTexture !== true ) {\r\n\r\n\t\t\tthrow new Error( 'TextureNode: Need a three.js texture.' );\r\n\r\n\t\t}\r\n\r\n\t\tconst textureProperty = super.generate( builder, 'texture' );\r\n\r\n\t\tif ( output === 'sampler' ) {\r\n\r\n\t\t\treturn textureProperty + '_sampler';\r\n\r\n\t\t} else if ( builder.isReference( output ) ) {\r\n\r\n\t\t\treturn textureProperty;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst nodeData = builder.getDataFromNode( this );\r\n\r\n\t\t\tlet snippet = nodeData.snippet;\r\n\r\n\t\t\tif ( snippet === undefined ) {\r\n\r\n\t\t\t\tconst uvSnippet = this.uvNode.build( builder, 'vec2' );\r\n\t\t\t\tconst levelNode = this.levelNode;\r\n\r\n\t\t\t\tif ( levelNode !== null ) {\r\n\r\n\t\t\t\t\tconst levelSnippet = levelNode.build( builder, 'float' );\r\n\r\n\t\t\t\t\tsnippet = builder.getTextureLevel( textureProperty, uvSnippet, levelSnippet );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tsnippet = builder.getTexture( textureProperty, uvSnippet );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnodeData.snippet = snippet;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn builder.format( snippet, 'vec4', output );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tserialize( data ) {\r\n\r\n\t\tsuper.serialize( data );\r\n\r\n\t\tdata.value = this.value.toJSON( data.meta ).uuid;\r\n\r\n\t}\r\n\r\n\tdeserialize( data ) {\r\n\r\n\t\tsuper.deserialize( data );\r\n\r\n\t\tthis.value = data.meta.textures[ data.value ];\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default TextureNode;\r\n", "import NodeUniform from './NodeUniform.js';\r\nimport NodeAttribute from './NodeAttribute.js';\r\nimport NodeVarying from './NodeVarying.js';\r\nimport NodeVar from './NodeVar.js';\r\nimport NodeCode from './NodeCode.js';\r\nimport NodeKeywords from './NodeKeywords.js';\r\nimport { NodeUpdateType } from './constants.js';\r\n\r\nimport { REVISION, LinearEncoding } from 'three';\r\n\r\nexport const defaultShaderStages = [ 'fragment', 'vertex' ];\r\nexport const shaderStages = [ ...defaultShaderStages, 'compute' ];\r\nexport const vector = [ 'x', 'y', 'z', 'w' ];\r\n\r\nconst typeFromLength = new Map();\r\ntypeFromLength.set( 1, 'float' );\r\ntypeFromLength.set( 2, 'vec2' );\r\ntypeFromLength.set( 3, 'vec3' );\r\ntypeFromLength.set( 4, 'vec4' );\r\ntypeFromLength.set( 9, 'mat3' );\r\ntypeFromLength.set( 16, 'mat4' );\r\n\r\nconst toFloat = ( value ) => {\r\n\r\n\tvalue = Number( value );\r\n\r\n\treturn value + ( value % 1 ? '' : '.0' );\r\n\r\n};\r\n\r\nclass NodeBuilder {\r\n\r\n\tconstructor( object, renderer, parser ) {\r\n\r\n\t\tthis.object = object;\r\n\t\tthis.material = object.material || null;\r\n\t\tthis.geometry = object.geometry || null;\r\n\t\tthis.renderer = renderer;\r\n\t\tthis.parser = parser;\r\n\r\n\t\tthis.nodes = [];\r\n\t\tthis.updateNodes = [];\r\n\t\tthis.hashNodes = {};\r\n\r\n\t\tthis.scene = null;\r\n\t\tthis.lightsNode = null;\r\n\t\tthis.fogNode = null;\r\n\r\n\t\tthis.vertexShader = null;\r\n\t\tthis.fragmentShader = null;\r\n\t\tthis.computeShader = null;\r\n\r\n\t\tthis.flowNodes = { vertex: [], fragment: [], compute: [] };\r\n\t\tthis.flowCode = { vertex: '', fragment: '', compute: [] };\r\n\t\tthis.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };\r\n\t\tthis.codes = { vertex: [], fragment: [], compute: [] };\r\n\t\tthis.attributes = [];\r\n\t\tthis.varyings = [];\r\n\t\tthis.vars = { vertex: [], fragment: [], compute: [] };\r\n\t\tthis.flow = { code: '' };\r\n\t\tthis.stack = [];\r\n\r\n\t\tthis.context = {\r\n\t\t\tkeywords: new NodeKeywords(),\r\n\t\t\tmaterial: object.material\r\n\t\t};\r\n\r\n\t\tthis.nodesData = new WeakMap();\r\n\t\tthis.flowsData = new WeakMap();\r\n\r\n\t\tthis.shaderStage = null;\r\n\t\tthis.buildStage = null;\r\n\r\n\t}\r\n\r\n\tget node() {\r\n\r\n\t\treturn this.stack[ this.stack.length - 1 ];\r\n\r\n\t}\r\n\r\n\taddStack( node ) {\r\n\r\n\t\t/*\r\n\t\tif ( this.stack.indexOf( node ) !== - 1 ) {\r\n\r\n\t\t\tconsole.warn( 'Recursive node: ', node );\r\n\r\n\t\t}\r\n\t\t*/\r\n\r\n\t\tthis.stack.push( node );\r\n\r\n\t}\r\n\r\n\tremoveStack( node ) {\r\n\r\n\t\tconst lastStack = this.stack.pop();\r\n\r\n\t\tif ( lastStack !== node ) {\r\n\r\n\t\t\tthrow new Error( 'NodeBuilder: Invalid node stack!' );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tsetHashNode( node, hash ) {\r\n\r\n\t\tthis.hashNodes[ hash ] = node;\r\n\r\n\t}\r\n\r\n\taddNode( node ) {\r\n\r\n\t\tif ( this.nodes.indexOf( node ) === - 1 ) {\r\n\r\n\t\t\tconst updateType = node.getUpdateType( this );\r\n\r\n\t\t\tif ( updateType !== NodeUpdateType.None ) {\r\n\r\n\t\t\t\tthis.updateNodes.push( node );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.nodes.push( node );\r\n\r\n\t\t\tthis.setHashNode( node, node.getHash( this ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgetMethod( method ) {\r\n\r\n\t\treturn method;\r\n\r\n\t}\r\n\r\n\tgetNodeFromHash( hash ) {\r\n\r\n\t\treturn this.hashNodes[ hash ];\r\n\r\n\t}\r\n\r\n\taddFlow( shaderStage, node ) {\r\n\r\n\t\tthis.flowNodes[ shaderStage ].push( node );\r\n\r\n\t\treturn node;\r\n\r\n\t}\r\n\r\n\tsetContext( context ) {\r\n\r\n\t\tthis.context = context;\r\n\r\n\t}\r\n\r\n\tgetContext() {\r\n\r\n\t\treturn this.context;\r\n\r\n\t}\r\n\r\n\tisAvailable( /*name*/ ) {\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tgetInstanceIndex() {\r\n\r\n\t\tconsole.warn( 'Abstract function.' );\r\n\r\n\t}\r\n\r\n\tgetFrontFacing() {\r\n\r\n\t\tconsole.warn( 'Abstract function.' );\r\n\r\n\t}\r\n\r\n\tgetTexture( /* textureProperty, uvSnippet */ ) {\r\n\r\n\t\tconsole.warn( 'Abstract function.' );\r\n\r\n\t}\r\n\r\n\tgetTextureLevel( /* textureProperty, uvSnippet, levelSnippet */ ) {\r\n\r\n\t\tconsole.warn( 'Abstract function.' );\r\n\r\n\t}\r\n\r\n\tgetCubeTexture( /* textureProperty, uvSnippet */ ) {\r\n\r\n\t\tconsole.warn( 'Abstract function.' );\r\n\r\n\t}\r\n\r\n\tgetCubeTextureLevel( /* textureProperty, uvSnippet, levelSnippet */ ) {\r\n\r\n\t\tconsole.warn( 'Abstract function.' );\r\n\r\n\t}\r\n\r\n\t// @TODO: rename to .generateConst()\r\n\tgetConst( type, value ) {\r\n\r\n\t\tif ( type === 'float' ) return toFloat( value );\r\n\t\tif ( type === 'int' ) return `${ Math.round( value ) }`;\r\n\t\tif ( type === 'uint' ) return value >= 0 ? `${ Math.round( value ) }u` : '0u';\r\n\t\tif ( type === 'bool' ) return value ? 'true' : 'false';\r\n\t\tif ( type === 'color' ) return `${ this.getType( 'vec3' ) }( ${ toFloat( value.r ) }, ${ toFloat( value.g ) }, ${ toFloat( value.b ) } )`;\r\n\r\n\t\tconst typeLength = this.getTypeLength( type );\r\n\r\n\t\tconst componentType = this.getComponentType( type );\r\n\r\n\t\tconst getConst = value => this.getConst( componentType, value );\r\n\r\n\t\tif ( typeLength === 2 ) {\r\n\r\n\t\t\treturn `${ this.getType( type ) }( ${ getConst( value.x ) }, ${ getConst( value.y ) } )`;\r\n\r\n\t\t} else if ( typeLength === 3 ) {\r\n\r\n\t\t\treturn `${ this.getType( type ) }( ${ getConst( value.x ) }, ${ getConst( value.y ) }, ${ getConst( value.z ) } )`;\r\n\r\n\t\t} else if ( typeLength === 4 ) {\r\n\r\n\t\t\treturn `${ this.getType( type ) }( ${ getConst( value.x ) }, ${ getConst( value.y ) }, ${ getConst( value.z ) }, ${ getConst( value.w ) } )`;\r\n\r\n\t\t} else if ( typeLength > 4 ) {\r\n\r\n\t\t\treturn `${ this.getType( type ) }()`;\r\n\r\n\t\t}\r\n\r\n\t\tthrow new Error( `NodeBuilder: Type '${type}' not found in generate constant attempt.` );\r\n\r\n\t}\r\n\r\n\tgetType( type ) {\r\n\r\n\t\treturn type;\r\n\r\n\t}\r\n\r\n\tgenerateMethod( method ) {\r\n\r\n\t\treturn method;\r\n\r\n\t}\r\n\r\n\tgetAttribute( name, type ) {\r\n\r\n\t\tconst attributes = this.attributes;\r\n\r\n\t\t// find attribute\r\n\r\n\t\tfor ( const attribute of attributes ) {\r\n\r\n\t\t\tif ( attribute.name === name ) {\r\n\r\n\t\t\t\treturn attribute;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// create a new if no exist\r\n\r\n\t\tconst attribute = new NodeAttribute( name, type );\r\n\r\n\t\tattributes.push( attribute );\r\n\r\n\t\treturn attribute;\r\n\r\n\t}\r\n\r\n\tgetPropertyName( node/*, shaderStage*/ ) {\r\n\r\n\t\treturn node.name;\r\n\r\n\t}\r\n\r\n\tisVector( type ) {\r\n\r\n\t\treturn /vec\\d/.test( type );\r\n\r\n\t}\r\n\r\n\tisMatrix( type ) {\r\n\r\n\t\treturn /mat\\d/.test( type );\r\n\r\n\t}\r\n\r\n\tisReference( type ) {\r\n\r\n\t\treturn type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture';\r\n\r\n\t}\r\n\r\n\tisShaderStage( shaderStage ) {\r\n\r\n\t\treturn this.shaderStage === shaderStage;\r\n\r\n\t}\r\n\r\n\tgetTextureEncodingFromMap( map ) {\r\n\r\n\t\tlet encoding;\r\n\r\n\t\tif ( map && map.isTexture ) {\r\n\r\n\t\t\tencoding = map.encoding;\r\n\r\n\t\t} else if ( map && map.isWebGLRenderTarget ) {\r\n\r\n\t\t\tencoding = map.texture.encoding;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tencoding = LinearEncoding;\r\n\r\n\t\t}\r\n\r\n\t\treturn encoding;\r\n\r\n\t}\r\n\r\n\tgetComponentType( type ) {\r\n\r\n\t\ttype = this.getVectorType( type );\r\n\r\n\t\tconst componentType = /(b|i|u|)(vec|mat)([2-4])/.exec( type );\r\n\r\n\t\tif ( componentType === null ) return null;\r\n\r\n\t\tif ( componentType[ 1 ] === 'b' ) return 'bool';\r\n\t\tif ( componentType[ 1 ] === 'i' ) return 'int';\r\n\t\tif ( componentType[ 1 ] === 'u' ) return 'uint';\r\n\r\n\t\treturn 'float';\r\n\r\n\t}\r\n\r\n\tgetVectorType( type ) {\r\n\r\n\t\tif ( type === 'color' ) return 'vec3';\r\n\t\tif ( type === 'texture' ) return 'vec4';\r\n\r\n\t\treturn type;\r\n\r\n\t}\r\n\r\n\tgetTypeFromLength( length ) {\r\n\r\n\t\treturn typeFromLength.get( length );\r\n\r\n\t}\r\n\r\n\tgetTypeLength( type ) {\r\n\r\n\t\tconst vecType = this.getVectorType( type );\r\n\t\tconst vecNum = /vec([2-4])/.exec( vecType );\r\n\r\n\t\tif ( vecNum !== null ) return Number( vecNum[ 1 ] );\r\n\t\tif ( vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint' ) return 1;\r\n\t\tif ( /mat3/.test( type ) === true ) return 9;\r\n\t\tif ( /mat4/.test( type ) === true ) return 16;\r\n\r\n\t\treturn 0;\r\n\r\n\t}\r\n\r\n\tgetVectorFromMatrix( type ) {\r\n\r\n\t\treturn type.replace( 'mat', 'vec' );\r\n\r\n\t}\r\n\r\n\tgetDataFromNode( node, shaderStage = this.shaderStage ) {\r\n\r\n\t\tlet nodeData = this.nodesData.get( node );\r\n\r\n\t\tif ( nodeData === undefined ) {\r\n\r\n\t\t\tnodeData = { vertex: {}, fragment: {}, compute: {} };\r\n\r\n\t\t\tthis.nodesData.set( node, nodeData );\r\n\r\n\t\t}\r\n\r\n\t\treturn shaderStage !== null ? nodeData[ shaderStage ] : nodeData;\r\n\r\n\t}\r\n\r\n\tgetNodeProperties( node, shaderStage = this.shaderStage ) {\r\n\r\n\t\tconst nodeData = this.getDataFromNode( this, shaderStage );\r\n\t\tconst constructHash = node.getConstructHash( this );\r\n\r\n\t\tnodeData.properties = nodeData.properties || {};\r\n\t\tnodeData.properties[ constructHash ] = nodeData.properties[ constructHash ] || { outputNode: null };\r\n\r\n\t\treturn nodeData.properties[ constructHash ];\r\n\r\n\t}\r\n\r\n\tgetUniformFromNode( node, shaderStage, type ) {\r\n\r\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\r\n\r\n\t\tlet nodeUniform = nodeData.uniform;\r\n\r\n\t\tif ( nodeUniform === undefined ) {\r\n\r\n\t\t\tconst index = this.uniforms.index ++;\r\n\r\n\t\t\tnodeUniform = new NodeUniform( 'nodeUniform' + index, type, node );\r\n\r\n\t\t\tthis.uniforms[ shaderStage ].push( nodeUniform );\r\n\r\n\t\t\tnodeData.uniform = nodeUniform;\r\n\r\n\t\t}\r\n\r\n\t\treturn nodeUniform;\r\n\r\n\t}\r\n\r\n\tgetVarFromNode( node, type, shaderStage = this.shaderStage ) {\r\n\r\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\r\n\r\n\t\tlet nodeVar = nodeData.variable;\r\n\r\n\t\tif ( nodeVar === undefined ) {\r\n\r\n\t\t\tconst vars = this.vars[ shaderStage ];\r\n\t\t\tconst index = vars.length;\r\n\r\n\t\t\tnodeVar = new NodeVar( 'nodeVar' + index, type );\r\n\r\n\t\t\tvars.push( nodeVar );\r\n\r\n\t\t\tnodeData.variable = nodeVar;\r\n\r\n\t\t}\r\n\r\n\t\treturn nodeVar;\r\n\r\n\t}\r\n\r\n\tgetVaryingFromNode( node, type ) {\r\n\r\n\t\tconst nodeData = this.getDataFromNode( node, null );\r\n\r\n\t\tlet nodeVarying = nodeData.varying;\r\n\r\n\t\tif ( nodeVarying === undefined ) {\r\n\r\n\t\t\tconst varyings = this.varyings;\r\n\t\t\tconst index = varyings.length;\r\n\r\n\t\t\tnodeVarying = new NodeVarying( 'nodeVarying' + index, type );\r\n\r\n\t\t\tvaryings.push( nodeVarying );\r\n\r\n\t\t\tnodeData.varying = nodeVarying;\r\n\r\n\t\t}\r\n\r\n\t\treturn nodeVarying;\r\n\r\n\t}\r\n\r\n\tgetCodeFromNode( node, type, shaderStage = this.shaderStage ) {\r\n\r\n\t\tconst nodeData = this.getDataFromNode( node );\r\n\r\n\t\tlet nodeCode = nodeData.code;\r\n\r\n\t\tif ( nodeCode === undefined ) {\r\n\r\n\t\t\tconst codes = this.codes[ shaderStage ];\r\n\t\t\tconst index = codes.length;\r\n\r\n\t\t\tnodeCode = new NodeCode( 'nodeCode' + index, type );\r\n\r\n\t\t\tcodes.push( nodeCode );\r\n\r\n\t\t\tnodeData.code = nodeCode;\r\n\r\n\t\t}\r\n\r\n\t\treturn nodeCode;\r\n\r\n\t}\r\n\r\n\taddFlowCode( code ) {\r\n\r\n\t\tthis.flow.code += code;\r\n\r\n\t}\r\n\r\n\tgetFlowData( node/*, shaderStage*/ ) {\r\n\r\n\t\treturn this.flowsData.get( node );\r\n\r\n\t}\r\n\r\n\tflowNode( node ) {\r\n\r\n\t\tconst output = node.getNodeType( this );\r\n\r\n\t\tconst flowData = this.flowChildNode( node, output );\r\n\r\n\t\tthis.flowsData.set( node, flowData );\r\n\r\n\t\treturn flowData;\r\n\r\n\t}\r\n\r\n\tflowChildNode( node, output = null ) {\r\n\r\n\t\tconst previousFlow = this.flow;\r\n\r\n\t\tconst flow = {\r\n\t\t\tcode: '',\r\n\t\t};\r\n\r\n\t\tthis.flow = flow;\r\n\r\n\t\tflow.result = node.build( this, output );\r\n\r\n\t\tthis.flow = previousFlow;\r\n\r\n\t\treturn flow;\r\n\r\n\t}\r\n\r\n\tflowNodeFromShaderStage( shaderStage, node, output = null, propertyName = null ) {\r\n\r\n\t\tconst previousShaderStage = this.shaderStage;\r\n\r\n\t\tthis.setShaderStage( shaderStage );\r\n\r\n\t\tconst flowData = this.flowChildNode( node, output );\r\n\r\n\t\tif ( propertyName !== null ) {\r\n\r\n\t\t\tflowData.code += `${propertyName} = ${flowData.result};\\n\\t`;\r\n\r\n\t\t}\r\n\r\n\t\tthis.flowCode[ shaderStage ] = this.flowCode[ shaderStage ] + flowData.code;\r\n\r\n\t\tthis.setShaderStage( previousShaderStage );\r\n\r\n\t\treturn flowData;\r\n\r\n\t}\r\n\r\n\tgetAttributes( /*shaderStage*/ ) {\r\n\r\n\t\tconsole.warn( 'Abstract function.' );\r\n\r\n\t}\r\n\r\n\tgetVaryings( /*shaderStage*/ ) {\r\n\r\n\t\tconsole.warn( 'Abstract function.' );\r\n\r\n\t}\r\n\r\n\tgetVars( shaderStage ) {\r\n\r\n\t\tlet snippet = '';\r\n\r\n\t\tconst vars = this.vars[ shaderStage ];\r\n\r\n\t\tfor ( const variable of vars ) {\r\n\r\n\t\t\tsnippet += `${variable.type} ${variable.name}; `;\r\n\r\n\t\t}\r\n\r\n\t\treturn snippet;\r\n\r\n\t}\r\n\r\n\tgetUniforms( /*shaderStage*/ ) {\r\n\r\n\t\tconsole.warn( 'Abstract function.' );\r\n\r\n\t}\r\n\r\n\tgetCodes( shaderStage ) {\r\n\r\n\t\tconst codes = this.codes[ shaderStage ];\r\n\r\n\t\tlet code = '';\r\n\r\n\t\tfor ( const nodeCode of codes ) {\r\n\r\n\t\t\tcode += nodeCode.code + '\\n';\r\n\r\n\t\t}\r\n\r\n\t\treturn code;\r\n\r\n\t}\r\n\r\n\tgetHash() {\r\n\r\n\t\treturn this.vertexShader + this.fragmentShader + this.computeShader;\r\n\r\n\t}\r\n\r\n\tsetShaderStage( shaderStage ) {\r\n\r\n\t\tthis.shaderStage = shaderStage;\r\n\r\n\t}\r\n\r\n\tgetShaderStage() {\r\n\r\n\t\treturn this.shaderStage;\r\n\r\n\t}\r\n\r\n\tsetBuildStage( buildStage ) {\r\n\r\n\t\tthis.buildStage = buildStage;\r\n\r\n\t}\r\n\r\n\tgetBuildStage() {\r\n\r\n\t\treturn this.buildStage;\r\n\r\n\t}\r\n\r\n\tbuildCode() {\r\n\r\n\t\tconsole.warn( 'Abstract function.' );\r\n\r\n\t}\r\n\r\n\tbuild() {\r\n\r\n\t\t// stage 1: generate shader node\r\n\r\n\t\tthis.setBuildStage( 'construct' );\r\n\r\n\t\tfor ( const shaderStage of shaderStages ) {\r\n\r\n\t\t\tthis.setShaderStage( shaderStage );\r\n\r\n\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\r\n\r\n\t\t\tfor ( const node of flowNodes ) {\r\n\r\n\t\t\t\tnode.build( this );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// stage 2: analyze nodes to possible optimization and validation\r\n\r\n\t\tthis.setBuildStage( 'analyze' );\r\n\r\n\t\tfor ( const shaderStage of shaderStages ) {\r\n\r\n\t\t\tthis.setShaderStage( shaderStage );\r\n\r\n\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\r\n\r\n\t\t\tfor ( const node of flowNodes ) {\r\n\r\n\t\t\t\tnode.build( this );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// stage 3: pre-build vertex code used in fragment shader\r\n\r\n\t\tthis.setBuildStage( 'generate' );\r\n\r\n\t\tif ( this.context.vertex && this.context.vertex.isNode ) {\r\n\r\n\t\t\tthis.flowNodeFromShaderStage( 'vertex', this.context.vertex );\r\n\r\n\t\t}\r\n\r\n\t\t// stage 4: generate shader\r\n\r\n\t\tthis.setBuildStage( 'generate' );\r\n\r\n\t\tfor ( const shaderStage of shaderStages ) {\r\n\r\n\t\t\tthis.setShaderStage( shaderStage );\r\n\r\n\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\r\n\r\n\t\t\tfor ( const node of flowNodes ) {\r\n\r\n\t\t\t\tthis.flowNode( node );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.setBuildStage( null );\r\n\t\tthis.setShaderStage( null );\r\n\r\n\t\t// stage 5: build code for a specific output\r\n\r\n\t\tthis.buildCode();\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tformat( snippet, fromType, toType ) {\r\n\r\n\t\tfromType = this.getVectorType( fromType );\r\n\t\ttoType = this.getVectorType( toType );\r\n\r\n\t\tif ( fromType === toType || toType === null || this.isReference( toType ) ) {\r\n\r\n\t\t\treturn snippet;\r\n\r\n\t\t}\r\n\r\n\t\tconst fromTypeLength = this.getTypeLength( fromType );\r\n\t\tconst toTypeLength = this.getTypeLength( toType );\r\n\r\n\t\tif ( fromTypeLength > 4 ) { // fromType is matrix-like\r\n\r\n\t\t\t// @TODO: ignore for now\r\n\r\n\t\t\treturn snippet;\r\n\r\n\t\t}\r\n\r\n\t\tif ( toTypeLength > 4 || toTypeLength === 0 ) { // toType is matrix-like or unknown\r\n\r\n\t\t\t// @TODO: ignore for now\r\n\r\n\t\t\treturn snippet;\r\n\r\n\t\t}\r\n\r\n\t\tif ( fromTypeLength === toTypeLength ) {\r\n\r\n\t\t\treturn `${ this.getType( toType ) }( ${ snippet } )`;\r\n\r\n\t\t}\r\n\r\n\t\tif ( fromTypeLength > toTypeLength ) {\r\n\r\n\t\t\treturn this.format( `${ snippet }.${ 'xyz'.slice( 0, toTypeLength ) }`, this.getTypeFromLength( toTypeLength ), toType );\r\n\r\n\t\t}\r\n\r\n\t\tif ( toTypeLength === 4 ) { // toType is vec4-like\r\n\r\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec3' ) }, 1.0 )`;\r\n\r\n\t\t}\r\n\r\n\t\tif ( fromTypeLength === 2 ) { // fromType is vec2-like and toType is vec3-like\r\n\r\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec2' ) }, 0.0 )`;\r\n\r\n\t\t}\r\n\r\n\t\treturn `${ this.getType( toType ) }( ${ snippet } )`; // fromType is float-like\r\n\r\n\t}\r\n\r\n\tgetSignature() {\r\n\r\n\t\treturn `// Three.js r${ REVISION } - NodeMaterial System\\n`;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default NodeBuilder;\r\n", "import Node from '../core/Node.js';\r\nimport { vector } from '../core/NodeBuilder.js';\r\n\r\nconst vectorComponents = 'xyzw';\r\n\r\nclass SplitNode extends Node {\r\n\r\n\tconstructor( node, components = 'x' ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.node = node;\r\n\t\tthis.components = components;\r\n\r\n\t}\r\n\r\n\tgetVectorLength() {\r\n\r\n\t\tlet vectorLength = this.components.length;\r\n\r\n\t\tfor ( const c of this.components ) {\r\n\r\n\t\t\tvectorLength = Math.max( vector.indexOf( c ) + 1, vectorLength );\r\n\r\n\t\t}\r\n\r\n\t\treturn vectorLength;\r\n\r\n\t}\r\n\r\n\tgetNodeType( builder ) {\r\n\r\n\t\treturn builder.getTypeFromLength( this.components.length );\r\n\r\n\t}\r\n\r\n\tgenerate( builder, output ) {\r\n\r\n\t\tconst node = this.node;\r\n\t\tconst nodeTypeLength = builder.getTypeLength( node.getNodeType( builder ) );\r\n\r\n\t\tlet snippet = null;\r\n\r\n\t\tif ( nodeTypeLength > 1 ) {\r\n\r\n\t\t\tlet type = null;\r\n\r\n\t\t\tconst componentsLength = this.getVectorLength();\r\n\r\n\t\t\tif ( componentsLength >= nodeTypeLength ) {\r\n\r\n\t\t\t\t// needed expand the input node\r\n\r\n\t\t\t\ttype = builder.getTypeFromLength( this.getVectorLength() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst nodeSnippet = node.build( builder, type );\r\n\r\n\t\t\tif ( this.components.length === nodeTypeLength && this.components === vectorComponents.slice( 0, this.components.length ) ) {\r\n\r\n\t\t\t\t// unecessary swizzle\r\n\r\n\t\t\t\tsnippet = builder.format( nodeSnippet, type, output );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tsnippet = builder.format( `${nodeSnippet}.${this.components}`, this.getNodeType( builder ), output );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// ignore .components if .node returns float/integer\r\n\r\n\t\t\tsnippet = node.build( builder, output );\r\n\r\n\t\t}\r\n\r\n\t\treturn snippet;\r\n\r\n\t}\r\n\r\n\tserialize( data ) {\r\n\r\n\t\tsuper.serialize( data );\r\n\r\n\t\tdata.components = this.components;\r\n\r\n\t}\r\n\r\n\tdeserialize( data ) {\r\n\r\n\t\tsuper.deserialize( data );\r\n\r\n\t\tthis.components = data.components;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default SplitNode;\r\n", "import Node from '../core/Node.js';\r\nimport OperatorNode from '../math/OperatorNode.js';\r\nimport MaterialReferenceNode from './MaterialReferenceNode.js';\r\nimport TextureNode from './TextureNode.js';\r\nimport SplitNode from '../utils/SplitNode.js';\r\n\r\nclass MaterialNode extends Node {\r\n\r\n\tstatic ALPHA_TEST = 'alphaTest';\r\n\tstatic COLOR = 'color';\r\n\tstatic OPACITY = 'opacity';\r\n\tstatic ROUGHNESS = 'roughness';\r\n\tstatic METALNESS = 'metalness';\r\n\tstatic EMISSIVE = 'emissive';\r\n\tstatic ROTATION = 'rotation';\r\n\r\n\tconstructor( scope = MaterialNode.COLOR ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.scope = scope;\r\n\r\n\t}\r\n\r\n\tgetNodeType( builder ) {\r\n\r\n\t\tconst scope = this.scope;\r\n\t\tconst material = builder.context.material;\r\n\r\n\t\tif ( scope === MaterialNode.COLOR ) {\r\n\r\n\t\t\treturn material.map !== null ? 'vec4' : 'vec3';\r\n\r\n\t\t} else if ( scope === MaterialNode.OPACITY || scope === MaterialNode.ROTATION ) {\r\n\r\n\t\t\treturn 'float';\r\n\r\n\t\t} else if ( scope === MaterialNode.EMISSIVE ) {\r\n\r\n\t\t\treturn 'vec3';\r\n\r\n\t\t} else if ( scope === MaterialNode.ROUGHNESS || scope === MaterialNode.METALNESS ) {\r\n\r\n\t\t\treturn 'float';\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgenerate( builder, output ) {\r\n\r\n\t\tconst material = builder.context.material;\r\n\t\tconst scope = this.scope;\r\n\r\n\t\tlet node = null;\r\n\r\n\t\tif ( scope === MaterialNode.ALPHA_TEST ) {\r\n\r\n\t\t\tnode = new MaterialReferenceNode( 'alphaTest', 'float' );\r\n\r\n\t\t} else if ( scope === MaterialNode.COLOR ) {\r\n\r\n\t\t\tconst colorNode = new MaterialReferenceNode( 'color', 'color' );\r\n\r\n\t\t\tif ( material.map?.isTexture === true ) {\r\n\r\n\t\t\t\t//new MaterialReferenceNode( 'map', 'texture' )\r\n\t\t\t\tconst map = new TextureNode( material.map );\r\n\r\n\t\t\t\tnode = new OperatorNode( '*', colorNode, map );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tnode = colorNode;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( scope === MaterialNode.OPACITY ) {\r\n\r\n\t\t\tconst opacityNode = new MaterialReferenceNode( 'opacity', 'float' );\r\n\r\n\t\t\tif ( material.alphaMap?.isTexture === true ) {\r\n\r\n\t\t\t\tnode = new OperatorNode( '*', opacityNode, new MaterialReferenceNode( 'alphaMap', 'texture' ) );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tnode = opacityNode;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( scope === MaterialNode.ROUGHNESS ) {\r\n\r\n\t\t\tconst roughnessNode = new MaterialReferenceNode( 'roughness', 'float' );\r\n\r\n\t\t\tif ( material.roughnessMap?.isTexture === true ) {\r\n\r\n\t\t\t\tnode = new OperatorNode( '*', roughnessNode, new SplitNode( new TextureNode( material.roughnessMap ), 'g' ) );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tnode = roughnessNode;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( scope === MaterialNode.METALNESS ) {\r\n\r\n\t\t\tconst metalnessNode = new MaterialReferenceNode( 'metalness', 'float' );\r\n\r\n\t\t\tif ( material.metalnessMap?.isTexture === true ) {\r\n\r\n\t\t\t\tnode = new OperatorNode( '*', metalnessNode, new SplitNode( new TextureNode( material.metalnessMap ), 'b' ) );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tnode = metalnessNode;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( scope === MaterialNode.EMISSIVE ) {\r\n\r\n\t\t\tconst emissiveNode = new MaterialReferenceNode( 'emissive', 'color' );\r\n\r\n\t\t\tif ( material.emissiveMap?.isTexture === true ) {\r\n\r\n\t\t\t\tnode = new OperatorNode( '*', emissiveNode, new TextureNode( material.emissiveMap ) );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tnode = emissiveNode;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( scope === MaterialNode.ROTATION ) {\r\n\r\n\t\t\tnode = new MaterialReferenceNode( 'rotation', 'float' );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst outputType = this.getNodeType( builder );\r\n\r\n\t\t\tnode = new MaterialReferenceNode( scope, outputType );\r\n\r\n\t\t}\r\n\r\n\t\treturn node.build( builder, output );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default MaterialNode;\r\n", "import Object3DNode from './Object3DNode.js';\r\n\r\nclass ModelNode extends Object3DNode {\r\n\r\n\tconstructor( scope = ModelNode.VIEW_MATRIX ) {\r\n\r\n\t\tsuper( scope );\r\n\r\n\t}\r\n\r\n\tupdate( frame ) {\r\n\r\n\t\tthis.object3d = frame.object;\r\n\r\n\t\tsuper.update( frame );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default ModelNode;\r\n", "import TempNode from '../core/TempNode.js';\r\nimport ExpressionNode from '../core/ExpressionNode.js';\r\nimport SplitNode from '../utils/SplitNode.js';\r\nimport OperatorNode from './OperatorNode.js';\r\n\r\nclass MathNode extends TempNode {\r\n\r\n\t// 1 input\r\n\r\n\tstatic RADIANS = 'radians';\r\n\tstatic DEGREES = 'degrees';\r\n\tstatic EXP = 'exp';\r\n\tstatic EXP2 = 'exp2';\r\n\tstatic LOG = 'log';\r\n\tstatic LOG2 = 'log2';\r\n\tstatic SQRT = 'sqrt';\r\n\tstatic INVERSE_SQRT = 'inversesqrt';\r\n\tstatic FLOOR = 'floor';\r\n\tstatic CEIL = 'ceil';\r\n\tstatic NORMALIZE = 'normalize';\r\n\tstatic FRACT = 'fract';\r\n\tstatic SIN = 'sin';\r\n\tstatic COS = 'cos';\r\n\tstatic TAN = 'tan';\r\n\tstatic ASIN = 'asin';\r\n\tstatic ACOS = 'acos';\r\n\tstatic ATAN = 'atan';\r\n\tstatic ABS = 'abs';\r\n\tstatic SIGN = 'sign';\r\n\tstatic LENGTH = 'length';\r\n\tstatic NEGATE = 'negate';\r\n\tstatic INVERT = 'invert';\r\n\tstatic DFDX = 'dFdx';\r\n\tstatic DFDY = 'dFdy';\r\n\tstatic SATURATE = 'saturate';\r\n\tstatic ROUND = 'round';\r\n\r\n\t// 2 inputs\r\n\r\n\tstatic ATAN2 = 'atan2';\r\n\tstatic MIN = 'min';\r\n\tstatic MAX = 'max';\r\n\tstatic MOD = 'mod';\r\n\tstatic STEP = 'step';\r\n\tstatic REFLECT = 'reflect';\r\n\tstatic DISTANCE = 'distance';\r\n\tstatic DOT = 'dot';\r\n\tstatic CROSS = 'cross';\r\n\tstatic POW = 'pow';\r\n\tstatic TRANSFORM_DIRECTION = 'transformDirection';\r\n\r\n\t// 3 inputs\r\n\r\n\tstatic MIX = 'mix';\r\n\tstatic CLAMP = 'clamp';\r\n\tstatic REFRACT = 'refract';\r\n\tstatic SMOOTHSTEP = 'smoothstep';\r\n\tstatic FACEFORWARD = 'faceforward';\r\n\r\n\tconstructor( method, aNode, bNode = null, cNode = null ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.method = method;\r\n\r\n\t\tthis.aNode = aNode;\r\n\t\tthis.bNode = bNode;\r\n\t\tthis.cNode = cNode;\r\n\r\n\t}\r\n\r\n\tgetInputType( builder ) {\r\n\r\n\t\tconst aType = this.aNode.getNodeType( builder );\r\n\t\tconst bType = this.bNode ? this.bNode.getNodeType( builder ) : null;\r\n\t\tconst cType = this.cNode ? this.cNode.getNodeType( builder ) : null;\r\n\r\n\t\tconst aLen = builder.isMatrix( aType ) ? 0 : builder.getTypeLength( aType );\r\n\t\tconst bLen = builder.isMatrix( bType ) ? 0 : builder.getTypeLength( bType );\r\n\t\tconst cLen = builder.isMatrix( cType ) ? 0 : builder.getTypeLength( cType );\r\n\r\n\t\tif ( aLen > bLen && aLen > cLen ) {\r\n\r\n\t\t\treturn aType;\r\n\r\n\t\t} else if ( bLen > cLen ) {\r\n\r\n\t\t\treturn bType;\r\n\r\n\t\t} else if ( cLen > aLen ) {\r\n\r\n\t\t\treturn cType;\r\n\r\n\t\t}\r\n\r\n\t\treturn aType;\r\n\r\n\t}\r\n\r\n\tgetNodeType( builder ) {\r\n\r\n\t\tconst method = this.method;\r\n\r\n\t\tif ( method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT ) {\r\n\r\n\t\t\treturn 'float';\r\n\r\n\t\t} else if ( method === MathNode.CROSS ) {\r\n\r\n\t\t\treturn 'vec3';\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn this.getInputType( builder );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgenerate( builder, output ) {\r\n\r\n\t\tconst method = this.method;\r\n\r\n\t\tconst type = this.getNodeType( builder );\r\n\t\tconst inputType = this.getInputType( builder );\r\n\r\n\t\tconst a = this.aNode;\r\n\t\tconst b = this.bNode;\r\n\t\tconst c = this.cNode;\r\n\r\n\t\tconst isWebGL = builder.renderer.isWebGLRenderer === true;\r\n\r\n\t\tif ( method === MathNode.TRANSFORM_DIRECTION ) {\r\n\r\n\t\t\t// dir can be either a direction vector or a normal vector\r\n\t\t\t// upper-left 3x3 of matrix is assumed to be orthogonal\r\n\r\n\t\t\tlet tA = a;\r\n\t\t\tlet tB = b;\r\n\r\n\t\t\tif ( builder.isMatrix( tA.getNodeType( builder ) ) ) {\r\n\r\n\t\t\t\ttB = new ExpressionNode( `${ builder.getType( 'vec4' ) }( ${ tB.build( builder, 'vec3' ) }, 0.0 )`, 'vec4' );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttA = new ExpressionNode( `${ builder.getType( 'vec4' ) }( ${ tA.build( builder, 'vec3' ) }, 0.0 )`, 'vec4' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst mulNode = new SplitNode( new OperatorNode( '*', tA, tB ), 'xyz' );\r\n\r\n\t\t\treturn new MathNode( MathNode.NORMALIZE, mulNode ).build( builder );\r\n\r\n\t\t} else if ( method === MathNode.SATURATE ) {\r\n\r\n\t\t\treturn builder.format( `clamp( ${ a.build( builder, inputType ) }, 0.0, 1.0 )`, type, output );\r\n\r\n\t\t} else if ( method === MathNode.NEGATE ) {\r\n\r\n\t\t\treturn builder.format( '( -' + a.build( builder, inputType ) + ' )', type, output );\r\n\r\n\t\t} else if ( method === MathNode.INVERT ) {\r\n\r\n\t\t\treturn builder.format( '( 1.0 - ' + a.build( builder, inputType ) + ' )', type, output );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst params = [];\r\n\r\n\t\t\tif ( method === MathNode.CROSS ) {\r\n\r\n\t\t\t\tparams.push(\r\n\t\t\t\t\ta.build( builder, type ),\r\n\t\t\t\t\tb.build( builder, type )\r\n\t\t\t\t);\r\n\r\n\t\t\t} else if ( method === MathNode.STEP ) {\r\n\r\n\t\t\t\tparams.push(\r\n\t\t\t\t\ta.build( builder, builder.getTypeLength( a.getNodeType( builder ) ) === 1 ? 'float' : inputType ),\r\n\t\t\t\t\tb.build( builder, inputType )\r\n\t\t\t\t);\r\n\r\n\t\t\t} else if ( ( isWebGL && ( method === MathNode.MIN || method === MathNode.MAX ) ) || method === MathNode.MOD ) {\r\n\r\n\t\t\t\tparams.push(\r\n\t\t\t\t\ta.build( builder, inputType ),\r\n\t\t\t\t\tb.build( builder, builder.getTypeLength( b.getNodeType( builder ) ) === 1 ? 'float' : inputType )\r\n\t\t\t\t);\r\n\r\n\t\t\t} else if ( method === MathNode.REFRACT ) {\r\n\r\n\t\t\t\tparams.push(\r\n\t\t\t\t\ta.build( builder, inputType ),\r\n\t\t\t\t\tb.build( builder, inputType ),\r\n\t\t\t\t\tc.build( builder, 'float' )\r\n\t\t\t\t);\r\n\r\n\t\t\t} else if ( method === MathNode.MIX ) {\r\n\r\n\t\t\t\tparams.push(\r\n\t\t\t\t\ta.build( builder, inputType ),\r\n\t\t\t\t\tb.build( builder, inputType ),\r\n\t\t\t\t\tc.build( builder, builder.getTypeLength( c.getNodeType( builder ) ) === 1 ? 'float' : inputType )\r\n\t\t\t\t);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tparams.push( a.build( builder, inputType ) );\r\n\r\n\t\t\t\tif ( c !== null ) {\r\n\r\n\t\t\t\t\tparams.push( b.build( builder, inputType ), c.build( builder, inputType ) );\r\n\r\n\t\t\t\t} else if ( b !== null ) {\r\n\r\n\t\t\t\t\tparams.push( b.build( builder, inputType ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn builder.format( `${ builder.getMethod( method ) }( ${params.join( ', ' )} )`, type, output );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tserialize( data ) {\r\n\r\n\t\tsuper.serialize( data );\r\n\r\n\t\tdata.method = this.method;\r\n\r\n\t}\r\n\r\n\tdeserialize( data ) {\r\n\r\n\t\tsuper.deserialize( data );\r\n\r\n\t\tthis.method = data.method;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default MathNode;\r\n", "import Node from '../core/Node.js';\r\nimport AttributeNode from '../core/AttributeNode.js';\r\nimport VaryingNode from '../core/VaryingNode.js';\r\nimport ModelNode from '../accessors/ModelNode.js';\r\nimport MathNode from '../math/MathNode.js';\r\nimport OperatorNode from '../math/OperatorNode.js';\r\n\r\nclass PositionNode extends Node {\r\n\r\n\tstatic GEOMETRY = 'geometry';\r\n\tstatic LOCAL = 'local';\r\n\tstatic WORLD = 'world';\r\n\tstatic VIEW = 'view';\r\n\tstatic VIEW_DIRECTION = 'viewDirection';\r\n\r\n\tconstructor( scope = PositionNode.LOCAL ) {\r\n\r\n\t\tsuper( 'vec3' );\r\n\r\n\t\tthis.scope = scope;\r\n\r\n\t}\r\n\r\n\tgetHash( /*builder*/ ) {\r\n\r\n\t\treturn `position-${this.scope}`;\r\n\r\n\t}\r\n\r\n\tgenerate( builder ) {\r\n\r\n\t\tconst scope = this.scope;\r\n\r\n\t\tlet outputNode = null;\r\n\r\n\t\tif ( scope === PositionNode.GEOMETRY ) {\r\n\r\n\t\t\toutputNode = new AttributeNode( 'position', 'vec3' );\r\n\r\n\t\t} else if ( scope === PositionNode.LOCAL ) {\r\n\r\n\t\t\toutputNode = new VaryingNode( new PositionNode( PositionNode.GEOMETRY ) );\r\n\r\n\t\t} else if ( scope === PositionNode.WORLD ) {\r\n\r\n\t\t\tconst vertexPositionNode = new MathNode( MathNode.TRANSFORM_DIRECTION, new ModelNode( ModelNode.WORLD_MATRIX ), new PositionNode( PositionNode.LOCAL ) );\r\n\t\t\toutputNode = new VaryingNode( vertexPositionNode );\r\n\r\n\t\t} else if ( scope === PositionNode.VIEW ) {\r\n\r\n\t\t\tconst vertexPositionNode = new OperatorNode( '*', new ModelNode( ModelNode.VIEW_MATRIX ), new PositionNode( PositionNode.LOCAL ) );\r\n\t\t\toutputNode = new VaryingNode( vertexPositionNode );\r\n\r\n\t\t} else if ( scope === PositionNode.VIEW_DIRECTION ) {\r\n\r\n\t\t\tconst vertexPositionNode = new MathNode( MathNode.NEGATE, new PositionNode( PositionNode.VIEW ) );\r\n\t\t\toutputNode = new MathNode( MathNode.NORMALIZE, new VaryingNode( vertexPositionNode ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn outputNode.build( builder, this.getNodeType( builder ) );\r\n\r\n\t}\r\n\r\n\tserialize( data ) {\r\n\r\n\t\tsuper.serialize( data );\r\n\r\n\t\tdata.scope = this.scope;\r\n\r\n\t}\r\n\r\n\tdeserialize( data ) {\r\n\r\n\t\tsuper.deserialize( data );\r\n\r\n\t\tthis.scope = data.scope;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default PositionNode;\r\n", "import Node from '../core/Node.js';\r\nimport CameraNode from '../accessors/CameraNode.js';\r\nimport ModelNode from '../accessors/ModelNode.js';\r\nimport OperatorNode from '../math/OperatorNode.js';\r\nimport PositionNode from '../accessors/PositionNode.js';\r\n\r\nclass ModelViewProjectionNode extends Node {\r\n\r\n\tconstructor( position = new PositionNode() ) {\r\n\r\n\t\tsuper( 'vec4' );\r\n\r\n\t\tthis.position = position;\r\n\r\n\t}\r\n\r\n\tgenerate( builder ) {\r\n\r\n\t\tconst position = this.position;\r\n\r\n\t\tconst mvpMatrix = new OperatorNode( '*', new CameraNode( CameraNode.PROJECTION_MATRIX ), new ModelNode( ModelNode.VIEW_MATRIX ) );\r\n\t\tconst mvpNode = new OperatorNode( '*', mvpMatrix, position );\r\n\r\n\t\treturn mvpNode.build( builder );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default ModelViewProjectionNode;\r\n", "import Node from '../core/Node.js';\r\nimport AttributeNode from '../core/AttributeNode.js';\r\nimport VaryingNode from '../core/VaryingNode.js';\r\nimport ModelNode from '../accessors/ModelNode.js';\r\nimport CameraNode from '../accessors/CameraNode.js';\r\nimport OperatorNode from '../math/OperatorNode.js';\r\nimport MathNode from '../math/MathNode.js';\r\n\r\nclass NormalNode extends Node {\r\n\r\n\tstatic GEOMETRY = 'geometry';\r\n\tstatic LOCAL = 'local';\r\n\tstatic WORLD = 'world';\r\n\tstatic VIEW = 'view';\r\n\r\n\tconstructor( scope = NormalNode.LOCAL ) {\r\n\r\n\t\tsuper( 'vec3' );\r\n\r\n\t\tthis.scope = scope;\r\n\r\n\t}\r\n\r\n\tgetHash( /*builder*/ ) {\r\n\r\n\t\treturn `normal-${this.scope}`;\r\n\r\n\t}\r\n\r\n\tgenerate( builder ) {\r\n\r\n\t\tconst scope = this.scope;\r\n\r\n\t\tlet outputNode = null;\r\n\r\n\t\tif ( scope === NormalNode.GEOMETRY ) {\r\n\r\n\t\t\toutputNode = new AttributeNode( 'normal', 'vec3' );\r\n\r\n\t\t} else if ( scope === NormalNode.LOCAL ) {\r\n\r\n\t\t\toutputNode = new VaryingNode( new NormalNode( NormalNode.GEOMETRY ) );\r\n\r\n\t\t} else if ( scope === NormalNode.VIEW ) {\r\n\r\n\t\t\tconst vertexNormalNode = new OperatorNode( '*', new ModelNode( ModelNode.NORMAL_MATRIX ), new NormalNode( NormalNode.LOCAL ) );\r\n\t\t\toutputNode = new MathNode( MathNode.NORMALIZE, new VaryingNode( vertexNormalNode ) );\r\n\r\n\t\t} else if ( scope === NormalNode.WORLD ) {\r\n\r\n\t\t\t// To use INVERSE_TRANSFORM_DIRECTION only inverse the param order like this: MathNode( ..., Vector, Matrix );\r\n\t\t\tconst vertexNormalNode = new MathNode( MathNode.TRANSFORM_DIRECTION, new NormalNode( NormalNode.VIEW ), new CameraNode( CameraNode.VIEW_MATRIX ) );\r\n\t\t\toutputNode = new MathNode( MathNode.NORMALIZE, new VaryingNode( vertexNormalNode ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn outputNode.build( builder );\r\n\r\n\t}\r\n\r\n\tserialize( data ) {\r\n\r\n\t\tsuper.serialize( data );\r\n\r\n\t\tdata.scope = this.scope;\r\n\r\n\t}\r\n\r\n\tdeserialize( data ) {\r\n\r\n\t\tsuper.deserialize( data );\r\n\r\n\t\tthis.scope = data.scope;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default NormalNode;\r\n", "import Node from '../core/Node.js';\r\n\r\nclass PointUVNode extends Node {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper( 'vec2' );\r\n\r\n\t\tthis.isPointUVNode = true;\r\n\r\n\t}\r\n\r\n\tgenerate( /*builder*/ ) {\r\n\r\n\t\treturn 'vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )';\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default PointUVNode;\r\n", "import BufferNode from './BufferNode.js';\r\n\r\nclass StorageBufferNode extends BufferNode {\r\n\r\n\tconstructor( value, bufferType, bufferCount = 0 ) {\r\n\r\n\t\tsuper( value, bufferType, bufferCount );\r\n\r\n\t\tthis.isStorageBufferNode = true;\r\n\r\n\t}\r\n\r\n\tgetInputType( /*builder*/ ) {\r\n\r\n\t\treturn 'storageBuffer';\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default StorageBufferNode;\r\n", "import ReferenceNode from './ReferenceNode.js';\r\n\r\nclass UserDataNode extends ReferenceNode {\r\n\r\n\tconstructor( property, inputType, userData = null ) {\r\n\r\n\t\tsuper( property, inputType, userData );\r\n\r\n\t\tthis.userData = userData;\r\n\r\n\t}\r\n\r\n\tupdate( frame ) {\r\n\r\n\t\tthis.object = this.userData !== null ? this.userData : frame.object.userData;\r\n\r\n\t\tsuper.update( frame );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default UserDataNode;\r\n", "import Node from '../core/Node.js';\r\n\r\nclass FrontFacingNode extends Node {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper( 'bool' );\r\n\r\n\t\tthis.isFrontFacingNode = true;\r\n\r\n\t}\r\n\r\n\tgenerate( builder ) {\r\n\r\n\t\treturn builder.getFrontFacing();\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default FrontFacingNode;\r\n", "import Node from '../core/Node.js';\r\nimport { NodeUpdateType } from '../core/constants.js';\r\n\r\nclass ComputeNode extends Node {\r\n\r\n\tconstructor( computeNode, count, workgroupSize = [ 64 ] ) {\r\n\r\n\t\tsuper( 'void' );\r\n\r\n\t\tthis.isComputeNode = true;\r\n\r\n\t\tthis.computeNode = computeNode;\r\n\r\n\t\tthis.count = count;\r\n\t\tthis.workgroupSize = workgroupSize;\r\n\t\tthis.dispatchCount = 0;\r\n\r\n\t\tthis.updateType = NodeUpdateType.Object;\r\n\r\n\t\tthis.updateDispatchCount();\r\n\r\n\t}\r\n\r\n\tupdateDispatchCount() {\r\n\r\n\t\tconst { count, workgroupSize } = this;\r\n\r\n\t\tlet size = workgroupSize[ 0 ];\r\n\r\n\t\tfor ( let i = 1; i < workgroupSize.length; i ++ )\r\n\t\t\tsize *= workgroupSize[ i ];\r\n\r\n\t\tthis.dispatchCount = Math.ceil( count / size );\r\n\r\n\t}\r\n\r\n\tonInit() { }\r\n\r\n\tupdate( { renderer } ) {\r\n\r\n\t\trenderer.compute( this );\r\n\r\n\t}\r\n\r\n\tgenerate( builder ) {\r\n\r\n\t\tconst { shaderStage } = builder;\r\n\r\n\t\tif ( shaderStage === 'compute' ) {\r\n\r\n\t\t\tconst snippet = this.computeNode.build( builder, 'void' );\r\n\r\n\t\t\tif ( snippet !== '' ) {\r\n\r\n\t\t\t\tbuilder.addFlowCode( snippet );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default ComputeNode;\r\n", "import Node from '../core/Node.js';\r\nimport PropertyNode from '../core/PropertyNode.js';\r\nimport ContextNode from '../core/ContextNode.js';\r\n\r\nclass CondNode extends Node {\r\n\r\n\tconstructor( condNode, ifNode, elseNode ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.condNode = condNode;\r\n\r\n\t\tthis.ifNode = ifNode;\r\n\t\tthis.elseNode = elseNode;\r\n\r\n\t}\r\n\r\n\tgetNodeType( builder ) {\r\n\r\n\t\tconst ifType = this.ifNode.getNodeType( builder );\r\n\t\tconst elseType = this.elseNode.getNodeType( builder );\r\n\r\n\t\tif ( builder.getTypeLength( elseType ) > builder.getTypeLength( ifType ) ) {\r\n\r\n\t\t\treturn elseType;\r\n\r\n\t\t}\r\n\r\n\t\treturn ifType;\r\n\r\n\t}\r\n\r\n\tgenerate( builder ) {\r\n\r\n\t\tconst type = this.getNodeType( builder );\r\n\r\n\t\tconst context = { tempWrite: false };\r\n\t\tconst nodeProperty = new PropertyNode( null, type ).build( builder );\r\n\r\n\t\tconst nodeSnippet = new ContextNode( this.condNode/*, context*/ ).build( builder, 'bool' ),\r\n\t\t\tifSnippet = new ContextNode( this.ifNode, context ).build( builder, type ),\r\n\t\t\telseSnippet = new ContextNode( this.elseNode, context ).build( builder, type );\r\n\r\n\t\tbuilder.addFlowCode( `if ( ${nodeSnippet} ) {\r\n\r\n\\t\\t${nodeProperty} = ${ifSnippet};\r\n\r\n\\t} else {\r\n\r\n\\t\\t${nodeProperty} = ${elseSnippet};\r\n\r\n\\t}` );\r\n\r\n\t\treturn nodeProperty;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default CondNode;\r\n", "import TempNode from '../core/Node.js';\r\n\r\nclass ArrayElementNode extends TempNode {\r\n\r\n\tconstructor( node, indexNode ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.node = node;\r\n\t\tthis.indexNode = indexNode;\r\n\r\n\t}\r\n\r\n\tgetNodeType( builder ) {\r\n\r\n\t\treturn this.node.getNodeType( builder );\r\n\r\n\t}\r\n\r\n\tgenerate( builder ) {\r\n\r\n\t\tconst nodeSnippet = this.node.build( builder );\r\n\t\tconst indexSnippet = this.indexNode.build( builder, 'uint' );\r\n\r\n\t\treturn `${nodeSnippet}[ ${indexSnippet} ]`;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default ArrayElementNode;\r\n", "import Node from '../core/Node.js';\r\n\r\nclass ConvertNode extends Node {\r\n\r\n\tconstructor( node, convertTo ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.node = node;\r\n\t\tthis.convertTo = convertTo;\r\n\r\n\t}\r\n\r\n\tgetNodeType( /*builder*/ ) {\r\n\r\n\t\treturn this.convertTo;\r\n\r\n\t}\r\n\r\n\tgenerate( builder, output ) {\r\n\r\n\t\tconst convertTo = this.convertTo;\r\n\t\tconst node = this.node;\r\n\t\tconst type = this.getNodeType( builder );\r\n\r\n\t\tlet snippet = null;\r\n\r\n\t\tif ( builder.isReference( convertTo ) === false ) {\r\n\r\n\t\t\tconst nodeSnippet = node.build( builder, convertTo );\r\n\r\n\t\t\tsnippet = builder.format( nodeSnippet, type, convertTo );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tsnippet = node.build( builder, convertTo );\r\n\r\n\t\t}\r\n\r\n\t\treturn builder.format( snippet, type, output );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default ConvertNode;\r\n", "import TempNode from '../core/Node.js';\r\n\r\nclass JoinNode extends TempNode {\r\n\r\n\tconstructor( nodes = [] ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.nodes = nodes;\r\n\r\n\t}\r\n\r\n\tgetNodeType( builder ) {\r\n\r\n\t\treturn builder.getTypeFromLength( this.nodes.reduce( ( count, cur ) => count + builder.getTypeLength( cur.getNodeType( builder ) ), 0 ) );\r\n\r\n\t}\r\n\r\n\tgenerate( builder, output ) {\r\n\r\n\t\tconst type = this.getNodeType( builder );\r\n\t\tconst nodes = this.nodes;\r\n\r\n\t\tconst snippetValues = [];\r\n\r\n\t\tfor ( const input of nodes ) {\r\n\r\n\t\t\tconst inputSnippet = input.build( builder );\r\n\r\n\t\t\tsnippetValues.push( inputSnippet );\r\n\r\n\t\t}\r\n\r\n\t\tconst snippet = `${ builder.getType( type ) }( ${ snippetValues.join( ', ' ) } )`;\r\n\r\n\t\treturn builder.format( snippet, type, output );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default JoinNode;\r\n", "import InputNode from './InputNode.js';\r\n\r\nclass ConstNode extends InputNode {\r\n\r\n\tconstructor( value, nodeType = null ) {\r\n\r\n\t\tsuper( value, nodeType );\r\n\r\n\t\tthis.isConstNode = true;\r\n\r\n\t}\r\n\r\n\tgenerateConst( builder ) {\r\n\r\n\t\treturn builder.getConst( this.getNodeType( builder ), this.value );\r\n\r\n\t}\r\n\r\n\tgenerate( builder, output ) {\r\n\r\n\t\tconst type = this.getNodeType( builder );\r\n\r\n\t\treturn builder.format( this.generateConst( builder ), type, output );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default ConstNode;\r\n", "import ArrayElementNode from '../utils/ArrayElementNode.js';\r\nimport ConvertNode from '../utils/ConvertNode.js';\r\nimport JoinNode from '../utils/JoinNode.js';\r\nimport SplitNode from '../utils/SplitNode.js';\r\nimport ConstNode from '../core/ConstNode.js';\r\nimport { getValueFromType } from '../core/NodeUtils.js';\r\n\r\nconst shaderNodeHandler = {\r\n\r\n\tconstruct( NodeClosure, params ) {\r\n\r\n\t\tconst inputs = params.shift();\r\n\r\n\t\treturn NodeClosure( nodeObjects( inputs ), ...params );\r\n\r\n\t},\r\n\r\n\tget: function ( node, prop ) {\r\n\r\n\t\tif ( typeof prop === 'string' && node[ prop ] === undefined ) {\r\n\r\n\t\t\tif ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true ) {\r\n\r\n\t\t\t\t// accessing properties ( swizzle )\r\n\r\n\t\t\t\tprop = prop\r\n\t\t\t\t\t.replace( /r|s/g, 'x' )\r\n\t\t\t\t\t.replace( /g|t/g, 'y' )\r\n\t\t\t\t\t.replace( /b|p/g, 'z' )\r\n\t\t\t\t\t.replace( /a|q/g, 'w' );\r\n\r\n\t\t\t\treturn nodeObject( new SplitNode( node, prop ) );\r\n\r\n\t\t\t} else if ( /^\\d+$/.test( prop ) === true ) {\r\n\r\n\t\t\t\t// accessing array\r\n\r\n\t\t\t\treturn nodeObject( new ArrayElementNode( node, new ConstNode( Number( prop ), 'uint' ) ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn node[ prop ];\r\n\r\n\t}\r\n\r\n};\r\n\r\nconst nodeObjectsCacheMap = new WeakMap();\r\n\r\nconst ShaderNodeObject = function ( obj ) {\r\n\r\n\tconst type = typeof obj;\r\n\r\n\tif ( ( type === 'number' ) || ( type === 'boolean' ) ) {\r\n\r\n\t\treturn nodeObject( getAutoTypedConstNode( obj ) );\r\n\r\n\t} else if ( type === 'object' ) {\r\n\r\n\t\tif ( obj?.isNode === true ) {\r\n\r\n\t\t\tlet nodeObject = nodeObjectsCacheMap.get( obj );\r\n\r\n\t\t\tif ( nodeObject === undefined ) {\r\n\r\n\t\t\t\tnodeObject = new Proxy( obj, shaderNodeHandler );\r\n\t\t\t\tnodeObjectsCacheMap.set( obj, nodeObject );\r\n\t\t\t\tnodeObjectsCacheMap.set( nodeObject, nodeObject );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn nodeObject;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn obj;\r\n\r\n};\r\n\r\nconst ShaderNodeObjects = function ( objects ) {\r\n\r\n\tfor ( const name in objects ) {\r\n\r\n\t\tobjects[ name ] = nodeObject( objects[ name ] );\r\n\r\n\t}\r\n\r\n\treturn objects;\r\n\r\n};\r\n\r\nconst ShaderNodeArray = function ( array ) {\r\n\r\n\tconst len = array.length;\r\n\r\n\tfor ( let i = 0; i < len; i ++ ) {\r\n\r\n\t\tarray[ i ] = nodeObject( array[ i ] );\r\n\r\n\t}\r\n\r\n\treturn array;\r\n\r\n};\r\n\r\nconst ShaderNodeProxy = function ( NodeClass, scope = null, factor = null ) {\r\n\r\n\tif ( scope === null ) {\r\n\r\n\t\treturn ( ...params ) => {\r\n\r\n\t\t\treturn nodeObject( new NodeClass( ...nodeArray( params ) ) );\r\n\r\n\t\t};\r\n\r\n\t} else if ( factor === null ) {\r\n\r\n\t\treturn ( ...params ) => {\r\n\r\n\t\t\treturn nodeObject( new NodeClass( scope, ...nodeArray( params ) ) );\r\n\r\n\t\t};\r\n\r\n\t} else {\r\n\r\n\t\tfactor = nodeObject( factor );\r\n\r\n\t\treturn ( ...params ) => {\r\n\r\n\t\t\treturn nodeObject( new NodeClass( scope, ...nodeArray( params ), factor ) );\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n};\r\n\r\nconst ShaderNodeImmutable = function ( NodeClass, ...params ) {\r\n\r\n\treturn nodeObject( new NodeClass( ...nodeArray( params ) ) );\r\n\r\n};\r\n\r\nconst ShaderNodeScript = function ( jsFunc ) {\r\n\r\n\t// @TODO: Move this to Node extended class\r\n\r\n\tconst self = {\r\n\r\n\t\tbuild: ( builder ) => {\r\n\r\n\t\t\tself.call( {}, builder );\r\n\r\n\t\t\treturn '';\r\n\r\n\t\t},\r\n\r\n\t\tcall: ( inputs, builder ) => {\r\n\r\n\t\t\tinputs = nodeObjects( inputs );\r\n\r\n\t\t\treturn nodeObject( jsFunc( inputs, builder ) );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\treturn self;\r\n\r\n};\r\n\r\nexport const ShaderNode = new Proxy( ShaderNodeScript, shaderNodeHandler );\r\n\r\nexport const nodeObject = ( val ) => /* new */ ShaderNodeObject( val );\r\nexport const nodeObjects = ( val ) => new ShaderNodeObjects( val );\r\nexport const nodeArray = ( val ) => new ShaderNodeArray( val );\r\nexport const nodeProxy = ( ...val ) => new ShaderNodeProxy( ...val );\r\nexport const nodeImmutable = ( ...val ) => new ShaderNodeImmutable( ...val );\r\n\r\nconst bools = [ false, true ];\r\nconst uints = [ 0, 1, 2, 3 ];\r\nconst ints = [ - 1, - 2 ];\r\nconst floats = [ 0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / ( Math.PI * 2 ), Math.PI / 2 ];\r\n\r\nconst boolsCacheMap = new Map();\r\nfor ( const bool of bools ) boolsCacheMap.set( bool, new ConstNode( bool ) );\r\n\r\nconst uintsCacheMap = new Map();\r\nfor ( const uint of uints ) uintsCacheMap.set( uint, new ConstNode( uint, 'uint' ) );\r\n\r\nconst intsCacheMap = new Map( [ ...uintsCacheMap ].map( el => new ConstNode( el.value, 'int' ) ) );\r\nfor ( const int of ints ) intsCacheMap.set( int, new ConstNode( int, 'int' ) );\r\n\r\nconst floatsCacheMap = new Map( [ ...intsCacheMap ].map( el => new ConstNode( el.value ) ) );\r\nfor ( const float of floats ) floatsCacheMap.set( float, new ConstNode( float ) );\r\nfor ( const float of floats ) floatsCacheMap.set( - float, new ConstNode( - float ) );\r\n\r\nexport const cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };\r\n\r\nconst constNodesCacheMap = new Map( [ ...boolsCacheMap, ...floatsCacheMap ] );\r\n\r\nconst getAutoTypedConstNode = ( value ) => {\r\n\r\n\tif ( constNodesCacheMap.has( value ) ) {\r\n\r\n\t\treturn constNodesCacheMap.get( value );\r\n\r\n\t} else if ( value.isNode === true ) {\r\n\r\n\t\treturn value;\r\n\r\n\t} else {\r\n\r\n\t\treturn new ConstNode( value );\r\n\r\n\t}\r\n\r\n};\r\n\r\nexport const ConvertType = function ( type, cacheMap = null ) {\r\n\r\n\treturn ( ...params ) => {\r\n\r\n\t\tif ( params.length === 0 ) {\r\n\r\n\t\t\treturn nodeObject( new ConstNode( getValueFromType( type ), type ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( type === 'color' && params[ 0 ].isNode !== true ) {\r\n\r\n\t\t\t\tparams = [ getValueFromType( type, ...params ) ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( params.length === 1 && cacheMap !== null && cacheMap.has( params[ 0 ] ) ) {\r\n\r\n\t\t\t\treturn cacheMap.get( params[ 0 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst nodes = params.map( getAutoTypedConstNode );\r\n\r\n\t\t\tif ( nodes.length === 1 ) {\r\n\r\n\t\t\t\treturn nodeObject( nodes[ 0 ].nodeType === type ? nodes[ 0 ] : new ConvertNode( nodes[ 0 ], type ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn nodeObject( new ConvertNode( new JoinNode( nodes ), type ) );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n};\r\n\r\nexport const getConstNodeType = ( value ) => value.nodeType || value.convertTo || ( typeof value === 'string' ? value : null );\r\n", "// core\r\n//import ArrayUniformNode from '../core/ArrayUniformNode.js';\r\nimport AttributeNode from '../core/AttributeNode.js';\r\nimport BypassNode from '../core/BypassNode.js';\r\nimport CodeNode from '../core/CodeNode.js';\r\nimport ContextNode from '../core/ContextNode.js';\r\nimport ExpressionNode from '../core/ExpressionNode.js';\r\nimport FunctionCallNode from '../core/FunctionCallNode.js';\r\nimport FunctionNode from '../core/FunctionNode.js';\r\nimport InstanceIndexNode from '../core/InstanceIndexNode.js';\r\nimport PropertyNode from '../core/PropertyNode.js';\r\nimport UniformNode from '../core/UniformNode.js';\r\nimport VarNode from '../core/VarNode.js';\r\nimport VaryingNode from '../core/VaryingNode.js';\r\n\r\n// accessors\r\nimport BufferNode from '../accessors/BufferNode.js';\r\nimport CameraNode from '../accessors/CameraNode.js';\r\nimport MaterialNode from '../accessors/MaterialNode.js';\r\nimport MaterialReferenceNode from '../accessors/MaterialReferenceNode.js';\r\nimport ModelViewProjectionNode from '../accessors/ModelViewProjectionNode.js';\r\nimport NormalNode from '../accessors/NormalNode.js';\r\nimport ModelNode from '../accessors/ModelNode.js';\r\nimport PointUVNode from '../accessors/PointUVNode.js';\r\nimport PositionNode from '../accessors/PositionNode.js';\r\nimport ReferenceNode from '../accessors/ReferenceNode.js';\r\nimport StorageBufferNode from '../accessors/StorageBufferNode.js';\r\nimport TextureNode from '../accessors/TextureNode.js';\r\nimport UserDataNode from '../accessors/UserDataNode.js';\r\nimport UVNode from '../accessors/UVNode.js';\r\n\r\n// display\r\nimport FrontFacingNode from '../display/FrontFacingNode.js';\r\n\r\n// gpgpu\r\nimport ComputeNode from '../gpgpu/ComputeNode.js';\r\n\r\n// math\r\nimport MathNode from '../math/MathNode.js';\r\nimport OperatorNode from '../math/OperatorNode.js';\r\nimport CondNode from '../math/CondNode.js';\r\n\r\n// utils\r\nimport ArrayElementNode from '../utils/ArrayElementNode.js';\r\nimport ConvertNode from '../utils/ConvertNode.js';\r\n\r\n// shader node utils\r\nimport { ShaderNode, nodeObject, nodeObjects, nodeArray, nodeProxy, nodeImmutable, ConvertType, getConstNodeType, cacheMaps } from './ShaderNode.js';\r\n\r\n// shader node base\r\n\r\nexport { ShaderNode, nodeObject, nodeObjects, nodeArray, nodeProxy, nodeImmutable };\r\n\r\nexport const color = new ConvertType( 'color' );\r\n\r\nexport const float = new ConvertType( 'float', cacheMaps.float );\r\nexport const int = new ConvertType( 'int', cacheMaps.int );\r\nexport const uint = new ConvertType( 'uint', cacheMaps.uint );\r\nexport const bool = new ConvertType( 'bool', cacheMaps.bool );\r\n\r\nexport const vec2 = new ConvertType( 'vec2' );\r\nexport const ivec2 = new ConvertType( 'ivec2' );\r\nexport const uvec2 = new ConvertType( 'uvec2' );\r\nexport const bvec2 = new ConvertType( 'bvec2' );\r\n\r\nexport const vec3 = new ConvertType( 'vec3' );\r\nexport const ivec3 = new ConvertType( 'ivec3' );\r\nexport const uvec3 = new ConvertType( 'uvec3' );\r\nexport const bvec3 = new ConvertType( 'bvec3' );\r\n\r\nexport const vec4 = new ConvertType( 'vec4' );\r\nexport const ivec4 = new ConvertType( 'ivec4' );\r\nexport const uvec4 = new ConvertType( 'uvec4' );\r\nexport const bvec4 = new ConvertType( 'bvec4' );\r\n\r\nexport const mat3 = new ConvertType( 'mat3' );\r\nexport const imat3 = new ConvertType( 'imat3' );\r\nexport const umat3 = new ConvertType( 'umat3' );\r\nexport const bmat3 = new ConvertType( 'bmat3' );\r\n\r\nexport const mat4 = new ConvertType( 'mat4' );\r\nexport const imat4 = new ConvertType( 'imat4' );\r\nexport const umat4 = new ConvertType( 'umat4' );\r\nexport const bmat4 = new ConvertType( 'bmat4' );\r\n\r\n// core\r\n\r\n// @TODO: ArrayUniformNode\r\n\r\nexport const func = ( code, includes ) => {\r\n\r\n\tconst node = nodeObject( new FunctionNode( code, includes ) );\r\n\r\n\tconst call = node.call.bind( node );\r\n\tnode.call = ( ...params ) => nodeObject( call( params.length > 1 || params[ 0 ]?.isNode === true ? nodeArray( params ) : nodeObjects( params[ 0 ] ) ) );\r\n\r\n\treturn node;\r\n\r\n};\r\n\r\nexport const uniform = ( nodeOrType ) => {\r\n\r\n\tconst nodeType = getConstNodeType( nodeOrType );\r\n\r\n\t// @TODO: get ConstNode from .traverse() in the future\r\n\tconst value = nodeOrType.isNode === true ? nodeOrType.node?.value || nodeOrType.value : nodeOrType;\r\n\r\n\treturn nodeObject( new UniformNode( value, nodeType ) );\r\n\r\n};\r\n\r\nexport const fn = ( code, includes ) => func( code, includes ).call;\r\n\r\nexport const attribute = ( name, nodeType ) => nodeObject( new AttributeNode( name, nodeType ) );\r\nexport const property = ( name, nodeOrType ) => nodeObject( new PropertyNode( name, getConstNodeType( nodeOrType ) ) );\r\n\r\nexport const bypass = nodeProxy( BypassNode );\r\nexport const code = nodeProxy( CodeNode );\r\nexport const context = nodeProxy( ContextNode );\r\nexport const expression = nodeProxy( ExpressionNode );\r\nexport const call = nodeProxy( FunctionCallNode );\r\nexport const instanceIndex = nodeImmutable( InstanceIndexNode );\r\nexport const label = nodeProxy( VarNode );\r\nexport const temp = label;\r\nexport const varying = nodeProxy( VaryingNode );\r\n\r\n// accesors\r\n\r\nexport const buffer = ( value, nodeOrType, count ) => nodeObject( new BufferNode( value, getConstNodeType( nodeOrType ), count ) );\r\nexport const storage = ( value, nodeOrType, count ) => nodeObject( new StorageBufferNode( value, getConstNodeType( nodeOrType ), count ) );\r\n\r\nexport const cameraProjectionMatrix = nodeImmutable( CameraNode, CameraNode.PROJECTION_MATRIX );\r\nexport const cameraViewMatrix = nodeImmutable( CameraNode, CameraNode.VIEW_MATRIX );\r\nexport const cameraNormalMatrix = nodeImmutable( CameraNode, CameraNode.NORMAL_MATRIX );\r\nexport const cameraWorldMatrix = nodeImmutable( CameraNode, CameraNode.WORLD_MATRIX );\r\nexport const cameraPosition = nodeImmutable( CameraNode, CameraNode.POSITION );\r\n\r\nexport const materialAlphaTest = nodeImmutable( MaterialNode, MaterialNode.ALPHA_TEST );\r\nexport const materialColor = nodeImmutable( MaterialNode, MaterialNode.COLOR );\r\nexport const materialEmissive = nodeImmutable( MaterialNode, MaterialNode.EMISSIVE );\r\nexport const materialOpacity = nodeImmutable( MaterialNode, MaterialNode.OPACITY );\r\n//export const materialSpecular = nodeImmutable( MaterialNode, MaterialNode.SPECULAR );\r\nexport const materialRoughness = nodeImmutable( MaterialNode, MaterialNode.ROUGHNESS );\r\nexport const materialMetalness = nodeImmutable( MaterialNode, MaterialNode.METALNESS );\r\nexport const materialRotation = nodeImmutable( MaterialNode, MaterialNode.ROTATION );\r\n\r\nexport const diffuseColor = nodeImmutable( PropertyNode, 'DiffuseColor', 'vec4' );\r\nexport const roughness = nodeImmutable( PropertyNode, 'Roughness', 'float' );\r\nexport const metalness = nodeImmutable( PropertyNode, 'Metalness', 'float' );\r\nexport const alphaTest = nodeImmutable( PropertyNode, 'AlphaTest', 'float' );\r\nexport const specularColor = nodeImmutable( PropertyNode, 'SpecularColor', 'color' );\r\n\r\nexport const reference = ( name, nodeOrType, object ) => nodeObject( new ReferenceNode( name, getConstNodeType( nodeOrType ), object ) );\r\nexport const materialReference = ( name, nodeOrType, material ) => nodeObject( new MaterialReferenceNode( name, getConstNodeType( nodeOrType ), material ) );\r\nexport const userData = ( name, inputType, userData ) => nodeObject( new UserDataNode( name, inputType, userData ) );\r\n\r\nexport const modelViewProjection = nodeProxy( ModelViewProjectionNode );\r\n\r\nexport const normalGeometry = nodeImmutable( NormalNode, NormalNode.GEOMETRY );\r\nexport const normalLocal = nodeImmutable( NormalNode, NormalNode.LOCAL );\r\nexport const normalWorld = nodeImmutable( NormalNode, NormalNode.WORLD );\r\nexport const normalView = nodeImmutable( NormalNode, NormalNode.VIEW );\r\nexport const transformedNormalView = nodeImmutable( VarNode, normalView, 'TransformedNormalView' );\r\n\r\nexport const modelViewMatrix = nodeImmutable( ModelNode, ModelNode.VIEW_MATRIX );\r\nexport const modelNormalMatrix = nodeImmutable( ModelNode, ModelNode.NORMAL_MATRIX );\r\nexport const modelWorldMatrix = nodeImmutable( ModelNode, ModelNode.WORLD_MATRIX );\r\nexport const modelPosition = nodeImmutable( ModelNode, ModelNode.POSITION );\r\nexport const modelViewPosition = nodeImmutable( ModelNode, ModelNode.VIEW_POSITION );\r\n\r\nexport const positionGeometry = nodeImmutable( PositionNode, PositionNode.GEOMETRY );\r\nexport const positionLocal = nodeImmutable( PositionNode, PositionNode.LOCAL );\r\nexport const positionWorld = nodeImmutable( PositionNode, PositionNode.WORLD );\r\nexport const positionView = nodeImmutable( PositionNode, PositionNode.VIEW );\r\nexport const positionViewDirection = nodeImmutable( PositionNode, PositionNode.VIEW_DIRECTION );\r\n\r\nexport const texture = nodeProxy( TextureNode );\r\nexport const sampler = ( texture ) => nodeObject( new ConvertNode( texture.isNode === true ? texture : new TextureNode( texture ), 'sampler' ) );\r\nexport const uv = ( ...params ) => nodeObject( new UVNode( ...params ) );\r\nexport const pointUV = nodeImmutable( PointUVNode );\r\n\r\n// gpgpu\r\n\r\nexport const compute = ( node, count, workgroupSize ) => nodeObject( new ComputeNode( nodeObject( node ), count, workgroupSize ) );\r\n\r\n// math\r\n\r\nexport const EPSILON = float( 1e-6 );\r\nexport const INFINITY = float( 1e6 );\r\n\r\nexport const cond = nodeProxy( CondNode );\r\n\r\nexport const add = nodeProxy( OperatorNode, '+' );\r\nexport const sub = nodeProxy( OperatorNode, '-' );\r\nexport const mul = nodeProxy( OperatorNode, '*' );\r\nexport const div = nodeProxy( OperatorNode, '/' );\r\nexport const remainder = nodeProxy( OperatorNode, '%' );\r\nexport const equal = nodeProxy( OperatorNode, '==' );\r\nexport const assign = nodeProxy( OperatorNode, '=' );\r\nexport const lessThan = nodeProxy( OperatorNode, '<' );\r\nexport const greaterThan = nodeProxy( OperatorNode, '>' );\r\nexport const lessThanEqual = nodeProxy( OperatorNode, '<=' );\r\nexport const greaterThanEqual = nodeProxy( OperatorNode, '>=' );\r\nexport const and = nodeProxy( OperatorNode, '&&' );\r\nexport const or = nodeProxy( OperatorNode, '||' );\r\nexport const xor = nodeProxy( OperatorNode, '^^' );\r\nexport const bitAnd = nodeProxy( OperatorNode, '&' );\r\nexport const bitOr = nodeProxy( OperatorNode, '|' );\r\nexport const bitXor = nodeProxy( OperatorNode, '^' );\r\nexport const shiftLeft = nodeProxy( OperatorNode, '<<' );\r\nexport const shiftRight = nodeProxy( OperatorNode, '>>' );\r\n\r\nexport const radians = nodeProxy( MathNode, MathNode.RADIANS );\r\nexport const degrees = nodeProxy( MathNode, MathNode.DEGREES );\r\nexport const exp = nodeProxy( MathNode, MathNode.EXP );\r\nexport const exp2 = nodeProxy( MathNode, MathNode.EXP2 );\r\nexport const log = nodeProxy( MathNode, MathNode.LOG );\r\nexport const log2 = nodeProxy( MathNode, MathNode.LOG2 );\r\nexport const sqrt = nodeProxy( MathNode, MathNode.SQRT );\r\nexport const inversesqrt = nodeProxy( MathNode, MathNode.INVERSE_SQRT );\r\nexport const floor = nodeProxy( MathNode, MathNode.FLOOR );\r\nexport const ceil = nodeProxy( MathNode, MathNode.CEIL );\r\nexport const normalize = nodeProxy( MathNode, MathNode.NORMALIZE );\r\nexport const fract = nodeProxy( MathNode, MathNode.FRACT );\r\nexport const sin = nodeProxy( MathNode, MathNode.SIN );\r\nexport const cos = nodeProxy( MathNode, MathNode.COS );\r\nexport const tan = nodeProxy( MathNode, MathNode.TAN );\r\nexport const asin = nodeProxy( MathNode, MathNode.ASIN );\r\nexport const acos = nodeProxy( MathNode, MathNode.ACOS );\r\nexport const atan = nodeProxy( MathNode, MathNode.ATAN );\r\nexport const abs = nodeProxy( MathNode, MathNode.ABS );\r\nexport const sign = nodeProxy( MathNode, MathNode.SIGN );\r\nexport const length = nodeProxy( MathNode, MathNode.LENGTH );\r\nexport const negate = nodeProxy( MathNode, MathNode.NEGATE );\r\nexport const invert = nodeProxy( MathNode, MathNode.INVERT );\r\nexport const dFdx = nodeProxy( MathNode, MathNode.DFDX );\r\nexport const dFdy = nodeProxy( MathNode, MathNode.DFDY );\r\nexport const saturate = nodeProxy( MathNode, MathNode.SATURATE );\r\nexport const round = nodeProxy( MathNode, MathNode.ROUND );\r\n\r\nexport const atan2 = nodeProxy( MathNode, MathNode.ATAN2 );\r\nexport const min = nodeProxy( MathNode, MathNode.MIN );\r\nexport const max = nodeProxy( MathNode, MathNode.MAX );\r\nexport const mod = nodeProxy( MathNode, MathNode.MOD );\r\nexport const step = nodeProxy( MathNode, MathNode.STEP );\r\nexport const reflect = nodeProxy( MathNode, MathNode.REFLECT );\r\nexport const distance = nodeProxy( MathNode, MathNode.DISTANCE );\r\nexport const dot = nodeProxy( MathNode, MathNode.DOT );\r\nexport const cross = nodeProxy( MathNode, MathNode.CROSS );\r\nexport const pow = nodeProxy( MathNode, MathNode.POW );\r\nexport const pow2 = nodeProxy( MathNode, MathNode.POW, 2 );\r\nexport const pow3 = nodeProxy( MathNode, MathNode.POW, 3 );\r\nexport const pow4 = nodeProxy( MathNode, MathNode.POW, 4 );\r\nexport const transformDirection = nodeProxy( MathNode, MathNode.TRANSFORM_DIRECTION );\r\n\r\nexport const mix = nodeProxy( MathNode, MathNode.MIX );\r\nexport const clamp = nodeProxy( MathNode, MathNode.CLAMP );\r\nexport const refract = nodeProxy( MathNode, MathNode.REFRACT );\r\nexport const smoothstep = nodeProxy( MathNode, MathNode.SMOOTHSTEP );\r\nexport const faceforward = nodeProxy( MathNode, MathNode.FACEFORWARD );\r\n\r\n// display\r\n\r\nexport const frontFacing = nodeImmutable( FrontFacingNode );\r\nexport const faceDirection = sub( mul( float( frontFacing ), 2 ), 1 );\r\n\r\n// lighting\r\n\r\n\r\n// utils\r\n\r\nexport const element = nodeProxy( ArrayElementNode );\r\n\r\n// miscellaneous\r\n\r\nexport const dotNV = saturate( dot( transformedNormalView, positionViewDirection ) );\r\nexport const transformedNormalWorld = normalize( transformDirection( transformedNormalView, cameraViewMatrix ) );\r\n"],
  "mappings": "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",
  "names": ["property", "property", "data", "attribute", "code", "context", "code", "property", "property", "property", "texture", "property", "userData", "context", "nodeObject", "bool", "uint", "int", "float", "code", "call", "userData", "texture"]
}
